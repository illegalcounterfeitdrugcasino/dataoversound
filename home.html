<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Color Flash Data Transfer 2.0</title>
    <style>
        :root {
            --primary-start: #667eea;
            --primary-end: #764ba2;
            --primary-text: white;
            --secondary-bg: #f3f4f6;
            --border-color: #e5e7eb;
            --text-dark: #374151;
            --text-light: #6b7280;
            --danger: #ef4444;
            --warning-bg: #fef3c7;
            --warning-text: #92400e;
            --warning-border: #fde68a;
            --success-bg: #dcfce7;
            --success-text: #166534;
        }

        /* General Styles */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background: #f0f2f5;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        /* Main Container */
        .container {
            background: white;
            border-radius: 24px;
            box-shadow: 0 25px 80px rgba(0,0,0,0.15);
            max-width: 900px;
            width: 100%;
            overflow: hidden;
            animation: slideIn 0.5s ease-out;
        }
        @keyframes slideIn { from { opacity: 0; transform: translateY(30px); } to { opacity: 1; transform: translateY(0); } }

        /* Header */
        .header {
            background: linear-gradient(135deg, var(--primary-start), var(--primary-end));
            padding: 30px;
            text-align: center;
            color: white;
        }
        .header h1 { font-size: 28px; font-weight: 700; margin-bottom: 8px; }
        .header p { opacity: 0.9; font-size: 14px; }

        /* Mode & Content Switching */
        .mode-selector { display: flex; background: #f7f7f7; padding: 8px; gap: 8px; }
        .mode-btn {
            flex: 1; padding: 16px; background: white; border: 2px solid transparent;
            border-radius: 12px; font-size: 16px; font-weight: 600; cursor: pointer;
            transition: all 0.3s ease; color: var(--text-light); position: relative;
        }
        .mode-btn:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
        .mode-btn.active {
            background: linear-gradient(135deg, var(--primary-start), var(--primary-end)); color: white;
            border-color: var(--primary-start); box-shadow: 0 4px 16px rgba(102, 126, 234, 0.3);
        }
        .content { padding: 30px; }
        .section { display: none; animation: fadeIn 0.3s ease-in; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        .section.active { display: block; }

        /* Forms & Inputs */
        .input-group { margin-bottom: 24px; }
        label { display: block; margin-bottom: 10px; font-weight: 600; color: var(--text-dark); font-size: 14px; }
        textarea, input[type="file"], input[type="number"], select {
            width: 100%; padding: 14px; border: 2px solid var(--border-color); border-radius: 12px;
            font-size: 14px; font-family: inherit; transition: all 0.3s ease; background: #fafafa;
        }
        textarea:focus, input:focus, select:focus {
            outline: none; border-color: var(--primary-start); background: white;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        textarea { min-height: 140px; resize: vertical; }

        /* Options Grid */
        .options {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px; margin-bottom: 20px; padding: 20px; background: #f9fafb;
            border-radius: 12px; border: 2px solid var(--border-color);
        }
        .option-item label { margin: 0; font-size: 14px; display: flex; align-items: center; gap: 8px; }

        /* Buttons */
        .btn {
            padding: 16px 32px; border: none; border-radius: 12px; font-size: 16px;
            font-weight: 600; cursor: pointer; transition: all 0.3s ease; width: 100%;
            margin-bottom: 12px; display: flex; justify-content: center; align-items: center; gap: 8px;
        }
        .btn-primary {
            background: linear-gradient(135deg, var(--primary-start), var(--primary-end)); color: white;
            box-shadow: 0 4px 16px rgba(102, 126, 234, 0.3);
        }
        .btn-primary:hover { transform: translateY(-2px); box-shadow: 0 6px 24px rgba(102, 126, 234, 0.4); }
        .btn-danger { background: var(--danger); color: white; box-shadow: 0 4px 16px rgba(239, 68, 68, 0.3); }
        .btn-danger:hover { background: #dc2626; transform: translateY(-2px); }

        /* Stats & Info */
        .stats {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 16px;
            margin-top: 24px; padding: 24px; background: linear-gradient(135deg, #f9fafb, #f3f4f6);
            border-radius: 12px; border: 2px solid var(--border-color);
        }
        .stat-item { text-align: center; }
        .stat-label { font-size: 12px; color: var(--text-light); margin-bottom: 8px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; }
        .stat-value { font-size: 24px; font-weight: bold; color: var(--primary-start); }
        .info-box {
            border-radius: 12px; padding: 16px; margin-bottom: 20px; font-size: 14px;
            line-height: 1.6; border: 2px solid;
        }
        .info-box.warning { background: var(--warning-bg); border-color: var(--warning-border); color: var(--warning-text); }
        .info-box.success { background: var(--success-bg); border-color: #86efac; color: var(--success-text); }
        .info-box strong { display: block; margin-bottom: 6px; font-size: 15px; }

        /* Transmission Screen */
        #flashContainer {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 9999; display: none; flex-wrap: wrap;
        }
        .flash-region { flex-grow: 1; flex-basis: 50%; }
        #flashContainer.active { display: flex; }
        #flashInfo {
            position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.85); backdrop-filter: blur(10px); color: white;
            padding: 18px 32px; border-radius: 16px; font-size: 16px;
            font-weight: 500; z-index: 10000; box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }

        /* Receiver UI */
        #cameraContainer { position: relative; width: 100%; background: #000; border-radius: 12px; overflow: hidden; }
        #cameraView { display: block; width: 100%; height: auto; }
        #cameraOverlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        .sample-point {
            position: absolute; border: 2px solid rgba(255, 0, 0, 0.7);
            width: 20px; height: 20px; background: rgba(255, 255, 255, 0.2);
            border-radius: 50%; transform: translate(-50%, -50%);
        }
        #receivedPreview {
            margin-top: 24px; padding: 24px; background: #f9fafb; border-radius: 12px;
            min-height: 120px; border: 2px solid var(--border-color);
        }
        #receivedData { font-family: 'Courier New', monospace; white-space: pre-wrap; word-break: break-all; color: var(--text-dark); }
        #downloadLink { display: none; margin-top: 10px; font-weight: bold; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Color Flash Transfer 2.0</h1>
            <p>Advanced data transmission using modulated light signals</p>
        </div>

        <div class="mode-selector">
            <button class="mode-btn active" onclick="ui.switchMode('send')">üì§ Send</button>
            <button class="mode-btn" onclick="ui.switchMode('receive')">üì• Receive</button>
        </div>

        <div class="content">
            <div id="sendMode" class="section active">
                <div class="input-group">
                    <label>Data Type:</label>
                    <select id="dataType" onchange="ui.updateDataType()" style="font-weight: 600;">
                        <option value="text">üìù Text</option>
                        <option value="file">üìÅ File</option>
                    </select>
                </div>

                <div id="textInput" class="input-group">
                    <label for="inputText">Enter Text:</label>
                    <textarea id="inputText" placeholder="Type your message here..."></textarea>
                </div>

                <div id="fileInput" class="input-group" style="display: none;">
                    <label for="inputFile">Select File:</label>
                    <input type="file" id="inputFile">
                </div>
                
                <div class="options">
                    <div class="option-item">
                        <label for="transmissionMode">Transmission Mode:</label>
                        <select id="transmissionMode" onchange="ui.updateModeInfo()">
                            <option value="standard">Standard (2 Colors, 1 bit/sym)</option>
                            <option value="turbo">Turbo (4 Colors, 2 bits/sym)</option>
                            <option value="hyper">Hyper (4 Regions, 8 bits/sym)</option>
                            <option value="ultra">Ultra (8 Colors, 3 bits/sym)</option>
                        </select>
                    </div>
                    <div class="option-item">
                        <label for="bitSpeed">Symbol Speed (ms):</label>
                        <input type="number" id="bitSpeed" value="100" min="20" max="500" step="10">
                    </div>
                </div>

                <div id="modeInfo" class="info-box warning">
                    <strong>‚ö° Turbo Mode</strong>
                    Uses 4 colors for 2x speed. Both devices must use this mode.
                </div>

                <button id="startSendBtn" class="btn btn-primary" onclick="transmitter.start()">üöÄ Start Transmission</button>
                <button id="stopSendBtn" class="btn btn-danger" onclick="transmitter.stop()" style="display:none;">‚èπÔ∏è Stop Transmission</button>


                <div id="sendStats" class="stats" style="display: none;">
                    <div class="stat-item">
                        <div class="stat-label">Size</div>
                        <div class="stat-value" id="dataSize">0 B</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Progress</div>
                        <div class="stat-value" id="progress">0%</div>
                    </div>
                     <div class="stat-item">
                        <div class="stat-label">Est. Time</div>
                        <div class="stat-value" id="timeRemaining">--</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Status</div>
                        <div class="stat-value" id="sendStatus" style="font-size: 18px;">Idle</div>
                    </div>
                </div>
            </div>

            <div id="receiveMode" class="section">
                 <div class="info-box">
                    <strong>üì± Setup Instructions:</strong>
                    1. Select the same Transmission Mode as the sender.<br>
                    2. Click "Start Camera" and point it at the sender's screen.<br>
                    3. For Hyper mode, align the four red circles with the four flashing regions. For other modes, center the circle on the flashing area.<br>
                    4. Click "Start Calibration" and wait for it to complete.
                </div>

                <div class="options">
                     <div class="option-item">
                        <label for="receiveModeSelect">Transmission Mode:</label>
                        <select id="receiveModeSelect" onchange="receiver.setMode(this.value)">
                            <option value="standard">Standard (2 Colors)</option>
                            <option value="turbo">Turbo (4 Colors)</option>
                            <option value="hyper">Hyper (4 Regions)</option>
                            <option value="ultra">Ultra (8 Colors)</option>
                        </select>
                    </div>
                </div>

                <div id="cameraContainer" style="display: none;">
                    <video id="cameraView" autoplay playsinline muted></video>
                    <div id="cameraOverlay"></div>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 20px;">
                    <button id="startCamBtn" class="btn btn-primary" onclick="receiver.startCamera()">üì∑ Start Camera</button>
                    <button id="stopCamBtn" class="btn btn-danger" onclick="receiver.stopCamera()" disabled>üõë Stop Camera</button>
                    <button id="startCalBtn" class="btn btn-primary" onclick="receiver.startCalibration()" disabled>üî¨ Start Calibration</button>
                    <button id="startRecBtn" class="btn btn-primary" onclick="receiver.startReceiving()" disabled>üì• Start Receiving</button>
                </div>
                 <button id="stopRecBtn" class="btn btn-danger" onclick="receiver.stopReceiving()" style="display:none; margin-top: 10px;">‚èπÔ∏è Stop Receiving</button>

                <div id="receiveStats" class="stats" style="display: none;">
                    <div class="stat-item">
                        <div class="stat-label">Status</div>
                        <div class="stat-value" id="receiveStatus" style="font-size: 18px;">Idle</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Received</div>
                        <div class="stat-value" id="receivedBits">0 bits</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Checksum</div>
                        <div class="stat-value" id="checksumStatus">--</div>
                    </div>
                </div>

                <div id="receivedPreview" style="display: none;">
                    <div class="stat-label">üìä Received Data:</div>
                    <div id="receivedData"></div>
                    <a id="downloadLink" href="#" download>‚¨áÔ∏è Download Received File</a>
                </div>
            </div>
        </div>
    </div>

    <div id="flashContainer">
        <div id="flashInfo">Preparing transmission...</div>
    </div>

<script>
// --- CONFIGURATION & CONSTANTS ---
const config = {
    PREAMBLE: [0, 1, 0, 1, 1, 0, 1, 0], // Start sequence
    PACKET_SIZE_BITS: 1024,
    MODES: {
        standard: {
            name: 'Standard',
            bitsPerSymbol: 1,
            regions: 1,
            palette: ['#ff0000', '#0000ff'],
            info: 'Uses 2 colors for baseline speed. Most reliable under poor lighting.'
        },
        turbo: {
            name: 'Turbo',
            bitsPerSymbol: 2,
            regions: 1,
            palette: ['#ff0000', '#00ff00', '#0000ff', '#ffff00'], // R, G, B, Y
            info: 'Uses 4 colors for 2x speed. Both devices must use this mode.'
        },
        ultra: {
            name: 'Ultra',
            bitsPerSymbol: 3,
            regions: 1,
            palette: [
                '#ff0000', '#00ff00', '#0000ff', '#ffff00', // R, G, B, Y
                '#00ffff', '#ff00ff', '#ffffff', '#444444'  // Cyan, Magenta, White, Gray(for Black)
            ],
            info: 'Uses 8 colors for 3x speed. Requires good camera and lighting.'
        },
        hyper: {
            name: 'Hyper',
            bitsPerSymbol: 2,
            regions: 4,
            palette: ['#ff0000', '#00ff00', '#0000ff', '#ffff00'], // Same as Turbo, but 4 regions
            info: 'Splits screen into 4 regions for 8x speed. Requires precise camera alignment.'
        }
    },
    SAMPLER: {
        POINTS: { // As percentages of view width/height
            standard: [{ x: 0.5, y: 0.5 }],
            turbo:    [{ x: 0.5, y: 0.5 }],
            ultra:    [{ x: 0.5, y: 0.5 }],
            hyper:    [
                { x: 0.25, y: 0.25 }, { x: 0.75, y: 0.25 },
                { x: 0.25, y: 0.75 }, { x: 0.75, y: 0.75 }
            ]
        }
    }
};

// --- UTILITIES ---
const utils = {
    // CRC32 Checksum for data integrity
    crc32: (function() {
        const table = new Uint32Array(256);
        for (let i = 0; i < 256; i++) {
            let c = i;
            for (let j = 0; j < 8; j++) {
                c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
            }
            table[i] = c;
        }
        return function(bytes) {
            let crc = -1;
            for (let i = 0; i < bytes.length; i++) {
                crc = (crc >>> 8) ^ table[(crc ^ bytes[i]) & 0xFF];
            }
            return (crc ^ -1) >>> 0;
        };
    })(),

    // Text <-> Byte array conversion (UTF-16)
    stringToBytes: str => {
        const bytes = [];
        for (let i = 0; i < str.length; i++) {
            const charCode = str.charCodeAt(i);
            bytes.push((charCode >> 8) & 0xFF, charCode & 0xFF);
        }
        return new Uint8Array(bytes);
    },
    bytesToString: bytes => {
        let str = '';
        for (let i = 0; i < bytes.length; i += 2) {
            str += String.fromCharCode((bytes[i] << 8) | (bytes[i + 1] || 0));
        }
        return str;
    },

    // Bit manipulation
    bytesToBits: bytes => {
        const bits = [];
        bytes.forEach(byte => {
            for (let i = 7; i >= 0; i--) bits.push((byte >> i) & 1);
        });
        return bits;
    },
    bitsToBytes: bits => {
        const bytes = [];
        for (let i = 0; i < bits.length; i += 8) {
            let byte = 0;
            for (let j = 0; j < 8; j++) {
                if (i + j < bits.length) byte = (byte << 1) | bits[i + j];
            }
            bytes.push(byte);
        }
        return new Uint8Array(bytes);
    },

    // Format bytes for display
    formatBytes: (bytes, decimals = 2) => {
        if (bytes === 0) return '0 B';
        const k = 1024;
        const dm = decimals < 0 ? 0 : decimals;
        const sizes = ['B', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
    },
    
    // Calculate color distance (more accurate than simple RGB checks)
    colorDistance: (c1, c2) => Math.sqrt(Math.pow(c1.r - c2.r, 2) + Math.pow(c1.g - c2.g, 2) + Math.pow(c1.b - c2.b, 2)),
};

// --- UI MANAGEMENT ---
const ui = {
    elements: {
        // General
        sendMode: document.getElementById('sendMode'),
        receiveMode: document.getElementById('receiveMode'),
        modeBtns: document.querySelectorAll('.mode-btn'),
        // Sender
        dataType: document.getElementById('dataType'),
        textInput: document.getElementById('textInput'),
        fileInput: document.getElementById('fileInput'),
        transmissionMode: document.getElementById('transmissionMode'),
        modeInfo: document.getElementById('modeInfo'),
        startSendBtn: document.getElementById('startSendBtn'),
        stopSendBtn: document.getElementById('stopSendBtn'),
        sendStats: document.getElementById('sendStats'),
        dataSize: document.getElementById('dataSize'),
        progress: document.getElementById('progress'),
        timeRemaining: document.getElementById('timeRemaining'),
        sendStatus: document.getElementById('sendStatus'),
        // Receiver
        receiveModeSelect: document.getElementById('receiveModeSelect'),
        cameraContainer: document.getElementById('cameraContainer'),
        cameraView: document.getElementById('cameraView'),
        cameraOverlay: document.getElementById('cameraOverlay'),
        startCamBtn: document.getElementById('startCamBtn'),
        stopCamBtn: document.getElementById('stopCamBtn'),
        startCalBtn: document.getElementById('startCalBtn'),
        startRecBtn: document.getElementById('startRecBtn'),
        stopRecBtn: document.getElementById('stopRecBtn'),
        receiveStats: document.getElementById('receiveStats'),
        receiveStatus: document.getElementById('receiveStatus'),
        receivedBits: document.getElementById('receivedBits'),
        checksumStatus: document.getElementById('checksumStatus'),
        receivedPreview: document.getElementById('receivedPreview'),
        receivedData: document.getElementById('receivedData'),
        downloadLink: document.getElementById('downloadLink'),
        // Flash Screen
        flashContainer: document.getElementById('flashContainer'),
        flashInfo: document.getElementById('flashInfo'),
    },
    
    switchMode: (mode) => {
        ui.elements.sendMode.classList.toggle('active', mode === 'send');
        ui.elements.receiveMode.classList.toggle('active', mode === 'receive');
        ui.elements.modeBtns.forEach(btn => btn.classList.toggle('active', btn.textContent.includes(mode.charAt(0).toUpperCase())));
        if (mode === 'send') transmitter.stop();
        if (mode === 'receive') receiver.stopCamera();
    },

    updateDataType: () => {
        const type = ui.elements.dataType.value;
        ui.elements.textInput.style.display = type === 'text' ? 'block' : 'none';
        ui.elements.fileInput.style.display = type === 'file' ? 'block' : 'none';
    },

    updateModeInfo: () => {
        const mode = config.MODES[ui.elements.transmissionMode.value];
        ui.elements.modeInfo.innerHTML = `<strong>‚ö° ${mode.name} Mode</strong> ${mode.info}`;
    },

    setSenderBusy: (busy) => {
        ui.elements.startSendBtn.style.display = busy ? 'none' : 'flex';
        ui.elements.stopSendBtn.style.display = busy ? 'flex' : 'none';
        ui.elements.sendStats.style.display = busy ? 'grid' : 'none';
        if (!busy) ui.updateStatus('sendStatus', 'Idle');
    },

    updateStatus: (elementId, text, color = '') => {
        const el = ui.elements[elementId];
        el.textContent = text;
        el.style.color = color;
    }
};

// --- SENDER LOGIC ---
const transmitter = {
    isActive: false,
    bitStream: [],
    currentBit: 0,
    startTime: 0,
    intervalId: null,

    prepareData: async () => {
        let payloadBytes;
        let header;
        const dataType = ui.elements.dataType.value;

        if (dataType === 'text') {
            const text = document.getElementById('inputText').value;
            if (!text) { alert('Please enter some text.'); return null; }
            header = `T:text/plain|`;
            payloadBytes = utils.stringToBytes(text);
        } else {
            const file = document.getElementById('inputFile').files[0];
            if (!file) { alert('Please select a file.'); return null; }
            header = `F:${file.name}|${file.type}|`;
            payloadBytes = new Uint8Array(await file.arrayBuffer());
        }

        const headerBytes = utils.stringToBytes(header);
        const combinedBytes = new Uint8Array(headerBytes.length + payloadBytes.length);
        combinedBytes.set(headerBytes, 0);
        combinedBytes.set(payloadBytes, headerBytes.length);
        
        const checksum = utils.crc32(combinedBytes);
        const checksumBytes = new Uint8Array(4);
        new DataView(checksumBytes.buffer).setUint32(0, checksum, false);

        const finalData = new Uint8Array(combinedBytes.length + 4);
        finalData.set(combinedBytes, 0);
        finalData.set(checksumBytes, combinedBytes.length);
        
        return finalData;
    },

    start: async function() {
        if (this.isActive) return;

        const dataBytes = await this.prepareData();
        if (!dataBytes) return;

        this.isActive = true;
        this.bitStream = [...config.PREAMBLE, ...utils.bytesToBits(dataBytes)];
        this.currentBit = 0;
        this.startTime = Date.now();
        ui.setSenderBusy(true);
        ui.elements.dataSize.textContent = utils.formatBytes(dataBytes.length);
        
        this.run();
    },

    stop: function() {
        this.isActive = false;
        clearInterval(this.intervalId);
        ui.elements.flashContainer.classList.remove('active');
        ui.setSenderBusy(false);
    },

    run: function() {
        const mode = config.MODES[ui.elements.transmissionMode.value];
        const speed = parseInt(document.getElementById('bitSpeed').value);
        const flashContainer = ui.elements.flashContainer;

        // Setup flash regions for Hyper mode
        flashContainer.innerHTML = ''; // Clear previous
        if (mode.regions > 1) {
            for (let i = 0; i < mode.regions; i++) {
                const region = document.createElement('div');
                region.className = 'flash-region';
                region.id = `flash-region-${i}`;
                flashContainer.appendChild(region);
            }
        }
        flashContainer.appendChild(ui.elements.flashInfo);
        flashContainer.classList.add('active');

        const step = () => {
            if (!this.isActive || this.currentBit >= this.bitStream.length) {
                this.stop();
                ui.updateStatus('sendStatus', 'Complete!', 'green');
                flashContainer.style.backgroundColor = 'green';
                setTimeout(() => { flashContainer.classList.remove('active'); }, 2000);
                return;
            }

            const bitsPerSymbolTotal = mode.bitsPerSymbol * mode.regions;
            
            // Set colors for each region
            for (let r = 0; r < mode.regions; r++) {
                const startBit = this.currentBit + (r * mode.bitsPerSymbol);
                const bitsForSymbol = this.bitStream.slice(startBit, startBit + mode.bitsPerSymbol);
                let symbolIndex = 0;
                for (let i = 0; i < bitsForSymbol.length; i++) {
                    symbolIndex = (symbolIndex << 1) | bitsForSymbol[i];
                }
                const color = mode.palette[symbolIndex] || '#000000'; // Default to black if out of bits
                
                if (mode.regions === 1) {
                    flashContainer.style.backgroundColor = color;
                } else {
                    document.getElementById(`flash-region-${r}`).style.backgroundColor = color;
                }
            }

            // Update stats
            const progress = (this.currentBit / this.bitStream.length * 100).toFixed(1);
            ui.elements.progress.textContent = `${progress}%`;
            const elapsed = Date.now() - this.startTime;
            const bitsPerMs = this.currentBit / (elapsed || 1);
            const remainingMs = (this.bitStream.length - this.currentBit) / bitsPerMs;
            ui.elements.timeRemaining.textContent = `${Math.ceil(remainingMs / 1000)}s`;
            ui.elements.sendStatus.textContent = `Transmitting`;
            ui.elements.flashInfo.textContent = `Symbol ${Math.floor(this.currentBit / bitsPerSymbolTotal)} / ${Math.ceil(this.bitStream.length / bitsPerSymbolTotal)}`;
            
            this.currentBit += bitsPerSymbolTotal;
        };

        this.intervalId = setInterval(step, speed);
    }
};

// --- RECEIVER LOGIC ---
const receiver = {
    isActive: false,
    isCalibrating: false,
    isReceiving: false,
    stream: null,
    animationFrameId: null,
    mode: 'standard',
    calibratedPalette: [],
    receivedBits: [],
    lastSymbolTime: 0,
    minSymbolInterval: 50, // Debounce time in ms
    state: 'idle', // idle, preamble, data

    setMode: function(mode) {
        this.mode = mode;
        this.drawSamplePoints();
    },

    startCamera: async function() {
        try {
            if (this.stream) this.stopCamera();
            this.stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });
            ui.elements.cameraView.srcObject = this.stream;
            ui.elements.cameraContainer.style.display = 'block';
            ui.elements.startCamBtn.disabled = true;
            ui.elements.stopCamBtn.disabled = false;
            ui.elements.startCalBtn.disabled = false;
            this.setMode(ui.elements.receiveModeSelect.value);
        } catch (err) {
            alert('Could not access camera: ' + err.message);
        }
    },

    stopCamera: function() {
        if (this.stream) this.stream.getTracks().forEach(track => track.stop());
        this.stream = null;
        this.stopReceiving();
        ui.elements.cameraView.srcObject = null;
        ui.elements.cameraContainer.style.display = 'none';
        ui.elements.startCamBtn.disabled = false;
        ui.elements.stopCamBtn.disabled = true;
        ui.elements.startCalBtn.disabled = true;
        ui.elements.startRecBtn.disabled = true;
    },

    drawSamplePoints: function() {
        const overlay = ui.elements.cameraOverlay;
        overlay.innerHTML = '';
        const points = config.SAMPLER.POINTS[this.mode];
        points.forEach(p => {
            const pointEl = document.createElement('div');
            pointEl.className = 'sample-point';
            pointEl.style.left = `${p.x * 100}%`;
            pointEl.style.top = `${p.y * 100}%`;
            overlay.appendChild(pointEl);
        });
    },

    startCalibration: function() {
        if (!this.stream || this.isCalibrating) return;
        this.isCalibrating = true;
        this.calibratedPalette = [];
        ui.updateStatus('receiveStatus', 'Calibrating...', 'orange');
        const modeConfig = config.MODES[this.mode];
        let colorIndex = 0;

        ui.elements.flashContainer.classList.add('active');
        
        const calibrationStep = () => {
            if (colorIndex >= modeConfig.palette.length) {
                // Calibration finished
                ui.elements.flashContainer.classList.remove('active');
                this.isCalibrating = false;
                ui.updateStatus('receiveStatus', 'Calibration OK', 'green');
                ui.elements.startRecBtn.disabled = false;
                alert(`Calibration complete for ${this.mode} mode! Ready to receive.`);
                return;
            }

            const colorToCalibrate = modeConfig.palette[colorIndex];
            ui.elements.flashContainer.style.backgroundColor = colorToCalibrate;
            ui.elements.flashInfo.textContent = `Point camera at this color: ${colorToCalibrate}`;

            // Give user time to point, then sample
            setTimeout(() => {
                const samples = this.sampleFrame();
                // For simplicity, we use the first sample point for non-hyper modes
                this.calibratedPalette.push(samples[0]);
                console.log(`Calibrated ${colorToCalibrate} as `, samples[0]);
                colorIndex++;
                calibrationStep();
            }, 2000);
        };
        calibrationStep();
    },

    startReceiving: function() {
        if (this.isReceiving || !this.stream || this.calibratedPalette.length === 0) {
            alert('Please start the camera and complete calibration first.');
            return;
        }
        this.isReceiving = true;
        this.receivedBits = [];
        this.state = 'preamble';
        
        ui.elements.receiveStats.style.display = 'grid';
        ui.elements.receivedPreview.style.display = 'block';
        ui.elements.downloadLink.style.display = 'none';
        ui.elements.receivedData.textContent = '';
        ui.elements.startRecBtn.style.display = 'none';
        ui.elements.stopRecBtn.style.display = 'flex';
        ui.updateStatus('receiveStatus', 'Waiting for Preamble...');
        ui.updateStatus('checksumStatus', '--');
        this.lastSymbolTime = Date.now();
        this.captureLoop();
    },

    stopReceiving: function() {
        this.isReceiving = false;
        cancelAnimationFrame(this.animationFrameId);
        ui.elements.startRecBtn.style.display = 'flex';
        ui.elements.stopRecBtn.style.display = 'none';
        ui.updateStatus('receiveStatus', 'Stopped');
    },

    captureLoop: function() {
        if (!this.isReceiving) return;

        const now = Date.now();
        if (now - this.lastSymbolTime > this.minSymbolInterval) {
            const samples = this.sampleFrame();
            if (samples.length > 0) {
                const bits = this.decodeSamples(samples);
                if (bits.length > 0) {
                    this.lastSymbolTime = now;
                    this.processBits(bits);
                }
            }
        }
        this.animationFrameId = requestAnimationFrame(() => this.captureLoop());
    },

    sampleFrame: function() {
        const video = ui.elements.cameraView;
        if (video.readyState < video.HAVE_METADATA) return [];

        const canvas = document.createElement('canvas');
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        ctx.drawImage(video, 0, 0);

        const samplePoints = config.SAMPLER.POINTS[this.mode];
        const samples = [];
        const sampleSize = 10; // Sample a 10x10 pixel area

        samplePoints.forEach(p => {
            const x = Math.floor(p.x * canvas.width - sampleSize / 2);
            const y = Math.floor(p.y * canvas.height - sampleSize / 2);
            const imageData = ctx.getImageData(x, y, sampleSize, sampleSize).data;
            
            let r = 0, g = 0, b = 0;
            for (let i = 0; i < imageData.length; i += 4) {
                r += imageData[i]; g += imageData[i + 1]; b += imageData[i + 2];
            }
            const pixelCount = imageData.length / 4;
            samples.push({ r: r / pixelCount, g: g / pixelCount, b: b / pixelCount });
        });
        return samples;
    },

    decodeSamples: function(samples) {
        const modeConfig = config.MODES[this.mode];
        const bitsPerSymbol = modeConfig.bitsPerSymbol;
        let decodedBits = [];

        samples.forEach(sample => {
            if (!sample) return;

            let closestColorIndex = -1;
            let minDistance = Infinity;

            this.calibratedPalette.forEach((calibratedColor, index) => {
                const distance = utils.colorDistance(sample, calibratedColor);
                if (distance < minDistance) {
                    minDistance = distance;
                    closestColorIndex = index;
                }
            });

            // Threshold to avoid detecting noise as a color
            if (minDistance < 100) {
                // Convert index to bits
                for (let i = bitsPerSymbol - 1; i >= 0; i--) {
                    decodedBits.push((closestColorIndex >> i) & 1);
                }
            }
        });
        return decodedBits;
    },

    processBits: function(bits) {
        if (bits.length === 0) return;
        
        this.receivedBits.push(...bits);

        if (this.state === 'preamble') {
            if (this.receivedBits.length >= config.PREAMBLE.length) {
                const receivedPreamble = this.receivedBits.slice(0, config.PREAMBLE.length).join('');
                if (receivedPreamble === config.PREAMBLE.join('')) {
                    this.state = 'data';
                    this.receivedBits = []; // Clear preamble from data
                    ui.updateStatus('receiveStatus', 'Receiving Data...', 'green');
                } else {
                    this.receivedBits.shift(); // Slide window
                }
            }
        } else if (this.state === 'data') {
            ui.elements.receivedBits.textContent = `${this.receivedBits.length} bits`;
            this.updatePreview();
        }
    },

    updatePreview: function() {
        if (this.receivedBits.length < 32) return;
        
        const bytes = utils.bitsToBytes(this.receivedBits);
        const headerStr = utils.bytesToString(bytes.slice(0, 50)); // Check first 100 bytes for header

        if (headerStr.startsWith('T:')) {
            const dataBytes = bytes.slice(0, bytes.length - 4); // Exclude checksum
            const checksumBytes = bytes.slice(bytes.length - 4);
            const dataStr = utils.bytesToString(dataBytes);
            
            const content = dataStr.substring(dataStr.indexOf('|') + 1);
            ui.elements.receivedData.textContent = content;

            // Verify checksum once we likely have all data (this is a guess)
            if (bytes.length > 50) { // arbitrary length to assume it's near the end
                this.verifyChecksum(dataBytes, checksumBytes);
            }
        } else if (headerStr.startsWith('F:')) {
            const parts = headerStr.split('|');
            const fileName = parts[0].substring(2);
            const fileType = parts[1];
            
            const dataBytes = bytes.slice(0, bytes.length - 4);
            const checksumBytes = bytes.slice(bytes.length - 4);
            const headerBytesLength = utils.stringToBytes(`${parts[0]}|${parts[1]}|`).length;
            
            ui.elements.receivedData.textContent = `Receiving file: ${fileName} (${fileType})...\n${utils.formatBytes(dataBytes.length)} received.`;

            if (this.verifyChecksum(dataBytes, checksumBytes)) {
                this.stopReceiving();
                ui.updateStatus('receiveStatus', 'File Received!', 'green');

                const fileBlob = new Blob([dataBytes.slice(headerBytesLength)], { type: fileType });
                const url = URL.createObjectURL(fileBlob);
                const a = ui.elements.downloadLink;
                a.href = url;
                a.download = fileName;
                a.style.display = 'block';
            }
        }
    },

    verifyChecksum: function(data, checksumBytes) {
        const receivedChecksum = new DataView(checksumBytes.buffer).getUint32(0, false);
        const calculatedChecksum = utils.crc32(data);

        if (receivedChecksum === calculatedChecksum) {
            ui.updateStatus('checksumStatus', 'OK', 'green');
            return true;
        } else {
            ui.updateStatus('checksumStatus', 'FAIL', 'red');
            return false;
        }
    }
};

// --- INITIALIZATION ---
window.onload = () => {
    ui.updateDataType();
    ui.updateModeInfo();
};

</script>
</body>
</html>

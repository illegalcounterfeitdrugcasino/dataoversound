<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LightSync Transfer</title>
    <style>
        :root {
            --bg-color: #121212;
            --surface-color: #1e1e1e;
            --primary-color: #007aff;
            --primary-light: #58a6ff;
            --text-color: #e0e0e0;
            --text-muted: #888888;
            --red: #ff453a;
            --green: #32d74b;
            --blue: #0a84ff;
            --yellow: #ffd60a;
            --border-color: #333333;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background: var(--bg-color);
            color: var(--text-color);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: var(--surface-color);
            border-radius: 24px;
            box-shadow: 0 25px 80px rgba(0,0,0,0.3);
            max-width: 600px;
            width: 100%;
            overflow: hidden;
            border: 1px solid var(--border-color);
            animation: slideIn 0.5s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .header {
            padding: 30px;
            text-align: center;
            border-bottom: 1px solid var(--border-color);
        }

        .header h1 {
            font-size: 28px;
            font-weight: 700;
            margin-bottom: 8px;
            background: linear-gradient(135deg, var(--primary-light) 0%, var(--primary-color) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .header p {
            color: var(--text-muted);
            font-size: 14px;
        }

        .mode-selector {
            display: flex;
            background: #111;
            padding: 8px;
            gap: 8px;
        }

        .mode-btn {
            flex: 1;
            padding: 16px;
            background: var(--surface-color);
            border: 2px solid transparent;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            color: var(--text-muted);
        }

        .mode-btn:hover {
            background: #2a2a2a;
            color: var(--text-color);
        }

        .mode-btn.active {
            background: var(--primary-color);
            color: white;
            box-shadow: 0 4px 16px rgba(0, 122, 255, 0.3);
        }

        .content {
            padding: 30px;
        }

        .section {
            display: none;
            animation: fadeIn 0.3s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .section.active {
            display: block;
        }

        .input-group {
            margin-bottom: 24px;
        }

        label {
            display: block;
            margin-bottom: 10px;
            font-weight: 600;
            color: var(--text-muted);
            font-size: 14px;
            text-transform: uppercase;
        }

        textarea {
            width: 100%;
            padding: 14px;
            border: 2px solid var(--border-color);
            border-radius: 12px;
            font-size: 14px;
            font-family: inherit;
            transition: all 0.3s ease;
            background: var(--bg-color);
            color: var(--text-color);
            min-height: 120px;
            resize: vertical;
        }

        textarea:focus {
            outline: none;
            border-color: var(--primary-color);
            background: var(--surface-color);
            box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.2);
        }
        
        .file-input-wrapper {
            position: relative;
            width: 100%;
            height: 120px;
            border: 2px dashed var(--border-color);
            border-radius: 12px;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            cursor: pointer;
            transition: all 0.3s ease;
            background: var(--bg-color);
        }
        .file-input-wrapper:hover {
            border-color: var(--primary-color);
            background: var(--surface-color);
        }
        .file-input-wrapper span {
            color: var(--text-muted);
            font-weight: 500;
        }
        .file-input-wrapper #fileName {
            font-weight: 600;
            color: var(--text-color);
            margin-top: 8px;
            font-size: 14px;
        }
        input[type="file"] {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            cursor: pointer;
        }

        .data-type-selector {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }

        .data-type-btn {
            padding: 12px;
            background: var(--bg-color);
            border: 2px solid var(--border-color);
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            color: var(--text-muted);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .data-type-btn:hover {
            border-color: var(--primary-color);
            color: var(--primary-color);
        }

        .data-type-btn.active {
            background: var(--surface-color);
            color: var(--primary-color);
            border-color: var(--primary-color);
        }

        button.primary {
            padding: 16px 32px;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            margin-bottom: 12px;
            box-shadow: 0 4px 16px rgba(0, 122, 255, 0.3);
        }

        button.primary:hover {
            transform: translateY(-2px);
            background: var(--primary-light);
            box-shadow: 0 6px 24px rgba(0, 122, 255, 0.4);
        }

        button.primary:active {
            transform: translateY(0);
        }

        button.danger {
            padding: 16px 32px;
            background: var(--red);
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            box-shadow: 0 4px 16px rgba(255, 69, 58, 0.3);
        }

        button.danger:hover {
            background: #ff6b62;
            transform: translateY(-2px);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
            box-shadow: none !important;
        }

        .info-box {
            background: rgba(0, 122, 255, 0.1);
            border: 1px solid var(--primary-color);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 20px;
            color: var(--primary-light);
            font-size: 14px;
            line-height: 1.6;
        }

        .info-box strong {
            display: block;
            margin-bottom: 6px;
            font-size: 15px;
            color: white;
        }

        #cameraFeed {
            width: 100%;
            aspect-ratio: 1 / 1;
            background: #000;
            border-radius: 12px;
            overflow: hidden;
            position: relative;
            border: 2px solid var(--border-color);
            margin-bottom: 20px;
            display: none;
        }
        
        #cameraView {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }
        
        #scanOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }
        
        #scanOverlay::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 3px;
            background: linear-gradient(90deg, transparent, var(--primary-light), transparent);
            box-shadow: 0 0 15px var(--primary-light);
            animation: scan 3s infinite ease-in-out;
        }
        
        @keyframes scan {
            0% { top: 0; }
            50% { top: calc(100% - 3px); }
            100% { top: 0; }
        }
        
        #scanOverlay .status-text {
            color: white;
            font-weight: 600;
            font-size: 16px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            background: rgba(0,0,0,0.5);
            padding: 8px 16px;
            border-radius: 8px;
            z-index: 2;
        }
        
        #receiveStatus {
            margin-top: 20px;
            text-align: center;
        }
        
        #receiveStatus .status-label {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-muted);
            margin-bottom: 12px;
        }
        
        #receiveProgress {
            width: 100%;
            height: 12px;
            -webkit-appearance: none;
            appearance: none;
            border: none;
            border-radius: 6px;
            overflow: hidden;
            background: var(--border-color);
        }
        
        #receiveProgress::-webkit-progress-bar {
            background: var(--border-color);
        }
        
        #receiveProgress::-webkit-progress-value {
            background: var(--primary-color);
            transition: width 0.1s linear;
        }
        
        #receiveProgress::-moz-progress-bar {
            background: var(--primary-color);
            transition: width 0.1s linear;
        }
        
        #receiveResult {
            margin-top: 24px; 
            padding: 24px;
            background: var(--bg-color);
            border-radius: 12px;
            min-height: 120px;
            border: 2px solid var(--border-color);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            gap: 12px;
        }
        
        #receivedText {
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
            word-break: break-all;
            line-height: 1.6;
            color: var(--text-color);
            width: 100%;
        }

        #receivedImageCanvas {
            max-width: 100%;
            border-radius: 12px;
            background: #000;
            image-rendering: pixelated;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        #overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 9998;
            display: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            backdrop-filter: blur(10px);
        }
        
        #overlay.active {
            display: block;
            opacity: 1;
        }
        
        #confirmModal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            background: var(--surface-color);
            border-radius: 20px;
            padding: 30px;
            z-index: 9999;
            width: 90%;
            max-width: 400px;
            text-align: center;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            border: 1px solid var(--border-color);
            display: none;
            opacity: 0;
            transition: all 0.3s ease;
        }
        
        #confirmModal.active {
            display: block;
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
        }
        
        #confirmModal h2 {
            font-size: 22px;
            margin-bottom: 12px;
        }
        
        #confirmModal p {
            color: var(--text-muted);
            margin-bottom: 24px;
            line-height: 1.5;
        }
        
        #confirmModal .modal-buttons {
            display: flex;
            gap: 12px;
        }
        
        #confirmModal .modal-buttons button {
            flex: 1;
            margin: 0;
        }
        
        button.secondary {
            background: var(--border-color);
            color: var(--text-color);
            box-shadow: none;
        }
        
        button.secondary:hover {
            background: #444;
            transform: translateY(-2px);
        }

        #flashScreen {
            position: fixed;
            top: 0;
            left: 0;
            /* Original had 33.33%, which is specific for left-edge placement */
            width: 33.3333%; 
            height: 100%;
            z-index: 10000;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: #fff;
        }

        #flashScreen.active {
            display: flex;
        }

        .flash-info {
            position: absolute;
            bottom: 30px;
            left: 50%; 
            transform: translateX(-50%);
            background: rgba(0,0,0,0.85);
            backdrop-filter: blur(10px);
            color: white;
            padding: 18px 32px;
            border-radius: 16px;
            font-size: 14px;
            font-weight: 500;
            z-index: 10001;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            white-space: nowrap;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>LightSync Transfer</h1>
            <p>Transfer data using flashes of colored light</p>
        </div>

        <div class="mode-selector">
            <button class="mode-btn active" onclick="switchMode('send')">üì§ Send</button>
            <button class="mode-btn" onclick="switchMode('receive')">üì• Receive</button>
        </div>

        <div class="content">
            <div id="sendMode" class="section active">
                <div class="input-group">
                    <label>Data Type</label>
                    <div class="data-type-selector">
                        <button class="data-type-btn active" onclick="switchDataType(event, 'text')">üìù Text</button>
                        <button class="data-type-btn" onclick="switchDataType(event, 'image')">üñºÔ∏è Image</button>
                        <button class="data-type-btn" onclick="switchDataType(event, 'file')">üìÅ File</button>
                    </div>
                </div>

                <div id="textInput" class="input-group">
                    <label>Enter Text:</label>
                    <textarea id="inputText" placeholder="Type your message here..."></textarea>
                </div>

                <div id="imageInput" class="input-group" style="display: none;">
                    <label>Select Image:</label>
                    <div class="file-input-wrapper">
                        <span>üñºÔ∏è Drag & Drop or Click</span>
                        <input type="file" id="inputImage" accept="image/*" onchange="updateFileName('inputImage', 'fileNameImage')">
                        <div id="fileNameImage" class="file-name"></div>
                    </div>
                </div>
                
                <div id="fileInput" class="input-group" style="display: none;">
                    <label>Select File:</label>
                    <div class="file-input-wrapper">
                        <span>üìÅ Drag & Drop or Click</span>
                        <input type="file" id="inputFile" onchange="updateFileName('inputFile', 'fileNameFile')">
                        <div id="fileNameFile" class="file-name"></div>
                    </div>
                </div>

                <button class="primary" id="startSendButton" onclick="showConfirmation()">üöÄ Start Transmission</button>
            </div>

            <div id="receiveMode" class="section">
                <div class="info-box">
                    <strong>üì± Setup Instructions:</strong>
                    1. Place your camera against the LEFT edge of the flashing screen<br>
                    2. Keep devices stable during transfer<br>
                    3. Press "Start Receiving"
                </div>

                <button class="primary" id="startReceiveBtn" onclick="startColorReceive()">üìπ Start Receiving</button>
                <button class="danger" id="stopReceiveBtn" onclick="stopReceiving()" style="display: none;">‚èπÔ∏è Stop</button>
                
                <div id="cameraFeed">
                    <video id="cameraView" autoplay playsinline muted></video>
                    <div id="scanOverlay">
                        <span id="scanStatusText" class="status-text">Scanning for signal...</span>
                    </div>
                </div>
                
                <div id="receiveStatus" style="display: none;">
                    <div id="statusLabel" class="status-label">Receiving data...</div>
                    <progress id="receiveProgress" value="0" max="100"></progress>
                </div>
                
                <div id="receiveResult">
                    <span style="color: var(--text-muted)">Waiting for data...</span>
                    <div id="receivedText"></div>
                    <canvas id="receivedImageCanvas"></canvas>
                </div>
            </div>
        </div>
    </div>

    <div id="overlay"></div>
    
    <div id="confirmModal">
        <h2>üöÄ Ready to Send?</h2>
        <p>This will black out your screen and begin the transfer. Please point the receiver's camera at the **left edge** of this screen.</p>
        <div class="modal-buttons">
            <button class="secondary" onclick="hideConfirmation()">Cancel</button>
            <button class="primary" onclick="startTransmission()">Confirm & Send</button>
        </div>
    </div>

    <div id="flashScreen">
        <div class="flash-info" id="flashInfo">Preparing...</div>
    </div>

    <script>
        // --- Constants ---
        const TRANSFER_SPEED_MS = 200;
        const IS_TURBO = true; // Hardcoded
        
        // Turbo colors: 2 bits per symbol
        const COLORS = {
            '00': '#ff0000', // Red
            '01': '#00ff00', // Green
            '10': '#0000ff', // Blue
            '11': '#ffff00', // Yellow
        };
        const COLOR_WHITE = '#ffffff';

        // Protocol sequences (must be 2-bit aligned for turbo)
        const HANDSHAKE_START = [0,1, 0,1, 0,1, 1,0, 1,0, 1,0]; // Green x3, Blue x3
        const HANDSHAKE_END =   [1,1, 0,0, 1,1, 0,0, 1,1, 0,0]; // Yellow x3, Red x3

        // --- Global State ---
        let currentMode = 'send';
        let currentDataType = 'text';
        let transmissionActive = false;
        let receivingActive = false;
        let bitStream = [];
        let currentBitIndex = 0;
        let receivedBits = [];
        let startTime = 0;
        
        let videoStream = null;
        let receiveState = 'IDLE'; // IDLE, RECEIVING, COMPLETE
        let liveDataBuffer = {
            type: null,
            headerParsed: false,
            headerString: '',
            payloadBytes: new Uint8Array(),
            meta: {},
            pixelsDrawn: 0,
            spiralGen: null,
        };

        // --- UI Functions ---

        function switchMode(mode) {
            currentMode = mode;
            document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`.mode-btn[onclick="switchMode('${mode}')"]`).classList.add('active');
            
            document.getElementById('sendMode').classList.toggle('active', mode === 'send');
            document.getElementById('receiveMode').classList.toggle('active', mode === 'receive');
            
            if (mode === 'receive' && receivingActive) {
                stopReceiving();
            }
            if (mode === 'send' && transmissionActive) {
                // Should not happen, but as a fallback
                transmissionActive = false;
                document.getElementById('flashScreen').classList.remove('active');
            }
        }

        function switchDataType(event, type) {
            currentDataType = type;
            document.querySelectorAll('.data-type-btn').forEach(btn => btn.classList.remove('active'));
            event.currentTarget.classList.add('active');

            document.getElementById('textInput').style.display = type === 'text' ? 'block' : 'none';
            document.getElementById('imageInput').style.display = type === 'image' ? 'block' : 'none';
            document.getElementById('fileInput').style.display = type === 'file' ? 'block' : 'none';
        }
        
        function updateFileName(inputId, labelId) {
            const file = document.getElementById(inputId).files[0];
            if (file) {
                document.getElementById(labelId).textContent = file.name;
            }
        }

        function showConfirmation() {
            document.getElementById('overlay').classList.add('active');
            document.getElementById('confirmModal').classList.add('active');
        }
        
        function hideConfirmation() {
            document.getElementById('overlay').classList.remove('active');
            document.getElementById('confirmModal').classList.remove('active');
        }

        // --- Data Conversion Utilities ---

        function stringToBytes(str) {
            // Use 2 bytes per char to support Unicode
            const bytes = [];
            for (let i = 0; i < str.length; i++) {
                const charCode = str.charCodeAt(i);
                bytes.push((charCode >> 8) & 0xFF);
                bytes.push(charCode & 0xFF);
            }
            return new Uint8Array(bytes);
        }

        function bytesToString(bytes) {
            let str = '';
            for (let i = 0; i < bytes.length; i += 2) {
                let charCode = (bytes[i] << 8) | (bytes[i + 1] || 0);
                str += String.fromCharCode(charCode);
            }
            return str;
        }

        function bytesToBits(bytes) {
            const bits = [];
            for (let i = 0; i < bytes.length; i++) {
                const byte = bytes[i];
                for (let j = 7; j >= 0; j--) {
                    bits.push((byte >> j) & 1);
                }
            }
            return bits;
        }

        function bitsToBytes(bits) {
            const bytes = [];
            for (let i = 0; i < bits.length; i += 8) {
                if(i + 7 > bits.length) break; // Only process full bytes
                let byte = 0;
                for (let j = 0; j < 8; j++) {
                    byte = (byte << 1) | bits[i + j];
                }
                bytes.push(byte);
            }
            return new Uint8Array(bytes);
        }
        
        // --- Spiral Image Utilities ---

        function* spiralGenerator(width, height) {
            let x = Math.floor(width / 2);
            let y = Math.floor(height / 2);
            let dx = 0;
            let dy = -1;
            let segmentLength = 1;
            let segmentPassed = 0;
            
            for (let i = 0; i < width * height; i++) {
                if (x >= 0 && x < width && y >= 0 && y < height) {
                    yield { x, y };
                }
                
                x += dx;
                y += dy;
                segmentPassed++;
                
                if (segmentPassed === segmentLength) {
                    segmentPassed = 0;
                    [dx, dy] = [-dy, dx]; // Turn 90 degrees
                    if (dy === 0) {
                        segmentLength++;
                    }
                }
            }
        }
        
        function getSpiralPixelData(imgData) {
            const { width, height, data } = imgData;
            const spiralPixels = new Uint8Array(width * height * 3);
            const spiralGen = spiralGenerator(width, height);
            
            for (let i = 0; i < width * height; i++) {
                const { x, y } = spiralGen.next().value;
                const dataIndex = (y * width + x) * 4;
                
                spiralPixels[i * 3]     = data[dataIndex];
                spiralPixels[i * 3 + 1] = data[dataIndex + 1];
                spiralPixels[i * 3 + 2] = data[dataIndex + 2];
            }
            return spiralPixels;
        }

        // --- Send Logic ---

        function loadImage(file) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.onerror = reject;
                img.src = URL.createObjectURL(file);
            });
        }
        
        function readFileAsArrayBuffer(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsArrayBuffer(file);
            });
        }

        async function prepareData() {
            let header = '';
            let payloadBytes = new Uint8Array();
            let dataDescription = '';

            if (currentDataType === 'text') {
                const text = document.getElementById('inputText').value;
                if (!text) {
                    alert('Please enter some text');
                    return null;
                }
                header = `T::`; // Type::
                payloadBytes = stringToBytes(text);
                dataDescription = `${payloadBytes.length} bytes of text`;
                
            } else if (currentDataType === 'image') {
                const file = document.getElementById('inputImage').files[0];
                if (!file) {
                    alert('Please select an image');
                    return null;
                }

                const img = await loadImage(file);
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                // Resize image to a max dimension for faster transfer
                const MAX_DIM = 128;
                let targetWidth = img.width;
                let targetHeight = img.height;
                if (targetWidth > MAX_DIM || targetHeight > MAX_DIM) {
                    if (targetWidth > targetHeight) {
                        targetHeight = Math.round(targetHeight * (MAX_DIM / targetWidth));
                        targetWidth = MAX_DIM;
                    } else {
                        targetWidth = Math.round(targetWidth * (MAX_DIM / targetHeight));
                        targetHeight = MAX_DIM;
                    }
                }
                
                canvas.width = targetWidth;
                canvas.height = targetHeight;
                ctx.drawImage(img, 0, 0, targetWidth, targetHeight);
                
                const imgData = ctx.getImageData(0, 0, targetWidth, targetHeight);
                
                // Re-order pixels into a spiral
                payloadBytes = getSpiralPixelData(imgData);

                header = `I:${targetWidth}:${targetHeight}:${file.name || 'image.png'}::`; // Type:Width:Height:Filename::
                dataDescription = `${targetWidth}x${targetHeight} image`;

            } else if (currentDataType === 'file') {
                const file = document.getElementById('inputFile').files[0];
                if (!file) {
                    alert('Please select a file');
                    return null;
                }
                const arrayBuffer = await readFileAsArrayBuffer(file);
                payloadBytes = new Uint8Array(arrayBuffer);
                header = `F:${file.name}:${payloadBytes.length}::`; // Type:Filename:Size::
                dataDescription = `${file.name} (${payloadBytes.length} bytes)`;
            }

            const headerBytes = stringToBytes(header);
            const combinedBytes = new Uint8Array(headerBytes.length + payloadBytes.length);
            combinedBytes.set(headerBytes, 0);
            combinedBytes.set(payloadBytes, headerBytes.length);

            const dataBits = bytesToBits(combinedBytes);
            bitStream = [...HANDSHAKE_START, ...dataBits, ...HANDSHAKE_END];
            return dataDescription;
        }

        async function startTransmission() {
            if (transmissionActive) return;
            
            hideConfirmation();
            const dataDescription = await prepareData();
            if (!dataDescription) return;

            transmissionActive = true;
            currentBitIndex = 0;
            startTime = Date.now();
            
            document.getElementById('startSendButton').disabled = true;

            startColorTransmission(dataDescription);
        }

        function startColorTransmission(dataDescription) {
            const flashScreen = document.getElementById('flashScreen');
            const flashInfo = document.getElementById('flashInfo');
            flashScreen.classList.add('active');
            
            const totalBits = bitStream.length;
            const handshakeBits = HANDSHAKE_START.length;
            const endBits = HANDSHAKE_END.length;
            const dataBits = totalBits - handshakeBits - endBits;

            function transmitNextSymbol() {
                if (!transmissionActive || currentBitIndex >= totalBits) {
                    flashScreen.style.backgroundColor = COLORS['01']; // Green for success
                    flashInfo.textContent = '‚úÖ Transmission Complete!';
                    setTimeout(() => {
                        flashScreen.classList.remove('active');
                        transmissionActive = false;
                        document.getElementById('startSendButton').disabled = false;
                    }, 2000);
                    return;
                }

                let color;
                let bitsToSend = 2; // Hardcoded for Turbo
                const bit1 = bitStream[currentBitIndex];
                const bit2 = bitStream[currentBitIndex + 1];
                
                if (bit1 === 0 && bit2 === 0) color = COLORS['00'];
                else if (bit1 === 0 && bit2 === 1) color = COLORS['01'];
                else if (bit1 === 1 && bit2 === 0) color = COLORS['10'];
                else color = COLORS['11'];

                flashScreen.style.backgroundColor = color;
                
                // Update Progress
                let progress = 0;
                let statusText = '';

                if (currentBitIndex < handshakeBits) {
                    statusText = 'Sending Handshake...';
                    progress = 0;
                } else if (currentBitIndex >= totalBits - endBits) {
                    statusText = 'Finalizing...';
                    progress = 100;
                } else {
                    const currentDataBit = currentBitIndex - handshakeBits;
                    progress = ((currentDataBit / dataBits) * 100).toFixed(1);
                    statusText = `Sending: ${progress}%`;
                }
                
                flashInfo.textContent = statusText;

                currentBitIndex += bitsToSend;

                // White separator flash
                setTimeout(() => {
                    if (!transmissionActive) return;
                    flashScreen.style.backgroundColor = COLOR_WHITE;
                    setTimeout(transmitNextSymbol, TRANSFER_SPEED_MS / 2);
                }, TRANSFER_SPEED_MS / 2);
            }

            flashInfo.textContent = `Starting: ${dataDescription}`;
            setTimeout(transmitNextSymbol, 1000); // Initial delay
        }

        // --- Receive Logic ---

        async function startColorReceive() {
            if (receivingActive) return;

            const video = document.getElementById('cameraView');
            const cameraFeed = document.getElementById('cameraFeed');
            const startBtn = document.getElementById('startReceiveBtn');
            const stopBtn = document.getElementById('stopReceiveBtn');
            
            try {
                videoStream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: 'environment', width: 640, height: 480 } 
                });
                video.srcObject = videoStream;
                video.onloadedmetadata = () => video.play();
                
                cameraFeed.style.display = 'block';
                startBtn.style.display = 'none';
                stopBtn.style.display = 'block';
                document.getElementById('receiveStatus').style.display = 'none';
                document.getElementById('receiveResult').innerHTML = '<span style="color: var(--text-muted)">Waiting for data...</span><div id="receivedText"></div><canvas id="receivedImageCanvas"></canvas>';
                
                receivingActive = true;
                receivedBits = [];
                receiveState = 'IDLE';
                resetLiveDataBuffer();
                
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d', { willReadFrequently: true });
                let waitingForSeparator = false;
                
                function captureFrame() {
                    if (!receivingActive) return;

                    if (video.readyState < video.HAVE_METADATA) {
                        requestAnimationFrame(captureFrame);
                        return;
                    }

                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    // Sample from the *left edge* of the camera feed
                    const sampleWidth = Math.min(100, canvas.width / 3);
                    const sampleHeight = 100;
                    const sampleX = 10; // Small offset from the very edge
                    const sampleY = canvas.height / 2 - sampleHeight / 2;

                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                    
                    const imageData = ctx.getImageData(sampleX, sampleY, sampleWidth, sampleHeight).data;
                    
                    let r = 0, g = 0, b = 0;
                    const pixelCount = imageData.length / 4;
                    for (let i = 0; i < imageData.length; i += 4) {
                        r += imageData[i];
                        g += imageData[i + 1];
                        b += imageData[i + 2];
                    }
                    r /= pixelCount;
                    g /= pixelCount;
                    b /= pixelCount;

                    // Detect white (separator)
                    if (r > 180 && g > 180 && b > 180) {
                        waitingForSeparator = false;
                    } else if (!waitingForSeparator) {
                        // Not white, try to detect a color
                        let bits = null;
                        
                        // Red = 00
                        if (r > 120 && g < 100 && b < 100) bits = [0, 0];
                        // Green = 01
                        else if (g > 120 && r < 100 && b < 100) bits = [0, 1];
                        // Blue = 10
                        else if (b > 120 && r < 100 && g < 100) bits = [1, 0];
                        // Yellow = 11
                        else if (r > 120 && g > 120 && b < 100) bits = [1, 1];

                        if (bits) {
                            waitingForSeparator = true;
                            processReceivedBits(bits);
                        }
                    }

                    requestAnimationFrame(captureFrame);
                }

                requestAnimationFrame(captureFrame);
                
            } catch (err) {
                alert('Camera access denied: ' + err.message);
                stopReceiving();
            }
        }
        
        function stopReceiving() {
            receivingActive = false;
            if (videoStream) {
                videoStream.getTracks().forEach(track => track.stop());
                videoStream = null;
            }
            document.getElementById('cameraView').srcObject = null;
            document.getElementById('cameraFeed').style.display = 'none';
            document.getElementById('startReceiveBtn').style.display = 'block';
            document.getElementById('stopReceiveBtn').style.display = 'none';
        }
        
        function arraysEqual(a1, a2) {
            if (a1.length !== a2.length) return false;
            for (let i = 0; i < a1.length; i++) {
                if (a1[i] !== a2[i]) return false;
            }
            return true;
        }

        function processReceivedBits(bits) {
            receivedBits.push(...bits);

            if (receiveState === 'IDLE') {
                document.getElementById('scanStatusText').textContent = 'Scanning for signal...';
                // Check if last bits match handshake
                if (receivedBits.length >= HANDSHAKE_START.length) {
                    const tail = receivedBits.slice(-HANDSHAKE_START.length);
                    if (arraysEqual(tail, HANDSHAKE_START)) {
                        receiveState = 'RECEIVING';
                        receivedBits = []; // Clear handshake from buffer
                        document.getElementById('scanStatusText').textContent = '‚úÖ Handshake OK!';
                        document.getElementById('receiveStatus').style.display = 'block';
                        document.getElementById('statusLabel').textContent = 'Receiving header...';
                    }
                }
                // Keep buffer from growing indefinitely
                if (receivedBits.length > 200) {
                    receivedBits = receivedBits.slice(-200);
                }
            } 
            else if (receiveState === 'RECEIVING') {
                // Check for end sequence
                if (receivedBits.length >= HANDSHAKE_END.length) {
                    const tail = receivedBits.slice(-HANDSHAKE_END.length);
                    if (arraysEqual(tail, HANDSHAKE_END)) {
                        receiveState = 'COMPLETE';
                        const finalDataBits = receivedBits.slice(0, -HANDSHAKE_END.length);
                        stopReceiving();
                        processFinalData(finalDataBits);
                        return;
                    }
                }
                
                // Live preview
                updateReceivedPreview();
            }
        }
        
        function resetLiveDataBuffer() {
            liveDataBuffer = {
                type: null,
                headerParsed: false,
                headerString: '',
                payloadBytes: new Uint8Array(),
                meta: {},
                pixelsDrawn: 0,
                spiralGen: null,
            };
        }

        function updateReceivedPreview() {
            if (!liveDataBuffer.headerParsed) {
                // Try to parse header
                const bytes = bitsToBytes(receivedBits);
                const headerTestString = bytesToString(bytes);
                const headerEndMarker = '::';
                const headerEndIndex = headerTestString.indexOf(headerEndMarker);
                
                if (headerEndIndex !== -1) {
                    // Header found!
                    liveDataBuffer.headerParsed = true;
                    liveDataBuffer.headerString = headerTestString.substring(0, headerEndIndex);
                    const parts = liveDataBuffer.headerString.split(':');
                    liveDataBuffer.type = parts[0];
                    
                    const headerBytesLength = stringToBytes(liveDataBuffer.headerString + headerEndMarker).length;
                    const headerBitsLength = headerBytesLength * 8;
                    
                    // Remove header bits from main buffer
                    receivedBits = receivedBits.slice(headerBitsLength);
                    
                    if (liveDataBuffer.type === 'T') {
                        document.getElementById('statusLabel').textContent = 'Receiving Text...';
                        document.getElementById('receiveResult').innerHTML = '<div id="receivedText" style="width: 100%"></div>'; // Clear
                    }
                    else if (liveDataBuffer.type === 'F') {
                        liveDataBuffer.meta.fileName = parts[1];
                        liveDataBuffer.meta.fileSize = parseInt(parts[2]);
                        document.getElementById('statusLabel').textContent = `Receiving File: ${liveDataBuffer.meta.fileName}`;
                        document.getElementById('receiveResult').innerHTML = ''; // Clear
                    }
                    else if (liveDataBuffer.type === 'I') {
                        liveDataBuffer.meta.width = parseInt(parts[1]);
                        liveDataBuffer.meta.height = parseInt(parts[2]);
                        liveDataBuffer.meta.fileName = parts[3];
                        liveDataBuffer.meta.totalPixels = liveDataBuffer.meta.width * liveDataBuffer.meta.height;
                        liveDataBuffer.meta.totalBytes = liveDataBuffer.meta.totalPixels * 3;
                        liveDataBuffer.spiralGen = spiralGenerator(liveDataBuffer.meta.width, liveDataBuffer.meta.height);

                        document.getElementById('statusLabel').textContent = `Receiving Image: ${liveDataBuffer.meta.width}x${liveDataBuffer.meta.height}`;
                        
                        const canvas = document.getElementById('receivedImageCanvas');
                        canvas.width = liveDataBuffer.meta.width;
                        canvas.height = liveDataBuffer.meta.height;
                        canvas.style.display = 'block';
                        document.getElementById('receiveResult').innerHTML = '';
                        document.getElementById('receiveResult').appendChild(canvas);
                    }
                }
            } 
            else {
                // Header is parsed, process payload
                const bytes = bitsToBytes(receivedBits);
                
                if (liveDataBuffer.type === 'T') {
                    document.getElementById('receivedText').textContent = bytesToString(bytes);
                    // No progress for text, it's usually short
                }
                else if (liveDataBuffer.type === 'F') {
                    const progress = (bytes.length / liveDataBuffer.meta.fileSize) * 100;
                    document.getElementById('receiveProgress').value = progress;
                }
                else if (liveDataBuffer.type === 'I') {
                    const canvas = document.getElementById('receivedImageCanvas');
                    const ctx = canvas.getContext('2d');
                    
                    const pixelsToDraw = Math.floor(bytes.length / 3);
                    const newPixels = pixelsToDraw - liveDataBuffer.pixelsDrawn;
                    
                    for (let i = 0; i < newPixels; i++) {
                        const pixelIndex = liveDataBuffer.pixelsDrawn + i;
                        if (pixelIndex >= liveDataBuffer.meta.totalPixels) break;
                        
                        const byteIndex = pixelIndex * 3;
                        if (byteIndex + 2 >= bytes.length) break;
                        
                        const r = bytes[byteIndex];
                        const g = bytes[byteIndex + 1];
                        const b = bytes[byteIndex + 2];
                        
                        const { x, y } = liveDataBuffer.spiralGen.next().value;
                        
                        ctx.fillStyle = `rgb(${r},${g},${b})`;
                        ctx.fillRect(x, y, 1, 1);
                    }
                    
                    liveDataBuffer.pixelsDrawn = pixelsToDraw;
                    const progress = (liveDataBuffer.pixelsDrawn / liveDataBuffer.meta.totalPixels) * 100;
                    document.getElementById('receiveProgress').value = progress;
                }
            }
        }
        
        function processFinalData(finalBits) {
            const finalBytes = bitsToBytes(finalBits);
            const { type, meta } = liveDataBuffer;
            
            document.getElementById('receiveStatus').style.display = 'none';
            const resultDiv = document.getElementById('receiveResult');
            resultDiv.innerHTML = '';
            
            let dataBytes;
            
            if (!liveDataBuffer.headerParsed) {
                // Fallback: If header was never parsed (e.g., text-only transfer)
                dataBytes = finalBytes;
            } else {
                // Get payload from final bits (live preview might have missed some)
                const headerBytesLength = stringToBytes(liveDataBuffer.headerString + '::').length;
                const headerBitsLength = headerBytesLength * 8;
                // This is a re-parse, but liveDataBuffer should have been used
                dataBytes = bitsToBytes(finalBits.slice(headerBitsLength));
            }

            if (type === 'T') {
                resultDiv.innerHTML = '<h3>‚úÖ Text Received:</h3>';
                const p = document.createElement('p');
                p.id = 'receivedText';
                p.textContent = bytesToString(dataBytes);
                resultDiv.appendChild(p);
            }
            else if (type === 'F') {
                resultDiv.innerHTML = `<h3>‚úÖ File Received: ${meta.fileName}</h3>`;
                const blob = new Blob([dataBytes], { type: 'application/octet-stream' });
                createDownloadLink(blob, meta.fileName);
            }
            else if (type === 'I') {
                resultDiv.innerHTML = `<h3>‚úÖ Image Received: ${meta.fileName}</h3>`;
                const canvas = document.getElementById('receivedImageCanvas');
                if (!canvas.style.display) {
                    // If canvas wasn't created, do a final draw
                    canvas.width = meta.width;
                    canvas.height = meta.height;
                    canvas.style.display = 'block';
                    const ctx = canvas.getContext('2d');
                    const spiralGen = spiralGenerator(meta.width, meta.height);
                    for (let i = 0; i < meta.totalPixels; i++) {
                        const byteIndex = i * 3;
                        const r = dataBytes[byteIndex];
                        const g = dataBytes[byteIndex + 1];
                        const b = dataBytes[byteIndex + 2];
                        const { x, y } = spiralGen.next().value;
                        ctx.fillStyle = `rgb(${r},${g},${b})`;
                        ctx.fillRect(x, y, 1, 1);
                    }
                }
                resultDiv.appendChild(canvas);
                
                canvas.toBlob(blob => {
                    createDownloadLink(blob, meta.fileName);
                }, 'image/png');
            }
        }
        
        function createDownloadLink(blob, fileName) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            a.textContent = `Download ${fileName}`;
            a.className = 'primary';
            a.style.width = 'auto';
            a.style.padding = '12px 24px';
            document.getElementById('receiveResult').appendChild(a);
        }

        // --- Lifecycle ---
        window.addEventListener('beforeunload', () => {
            transmissionActive = false;
            stopReceiving();
        });
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PhotonSend - Epic Data Transfer</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #f0f2f5;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 24px;
            box-shadow: 0 25px 80px rgba(0,0,0,0.1);
            max-width: 700px;
            width: 100%;
            overflow: hidden;
            animation: slideIn 0.5s ease-out;
            position: relative;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateY(30px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .header {
            background: linear-gradient(135deg, #007aff 0%, #00c6ff 100%);
            padding: 30px;
            text-align: center;
            color: white;
        }

        .header h1 {
            font-size: 28px;
            font-weight: 700;
            margin-bottom: 8px;
        }

        .header p {
            opacity: 0.9;
            font-size: 14px;
        }

        .mode-selector {
            display: flex;
            background: #e9ecef;
            padding: 8px;
            gap: 8px;
        }

        .mode-btn {
            flex: 1;
            padding: 16px;
            background: transparent;
            border: 2px solid transparent;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            color: #495057;
        }

        .mode-btn:hover {
            background: #dee2e6;
        }

        .mode-btn.active {
            background: white;
            color: #007aff;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
        }

        .content {
            padding: 30px;
        }

        .section {
            display: none;
            animation: fadeIn 0.3s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .section.active {
            display: block;
        }

        .input-group {
            margin-bottom: 24px;
        }

        label {
            display: block;
            margin-bottom: 10px;
            font-weight: 600;
            color: #333;
            font-size: 14px;
        }

        textarea, input[type="file"] {
            width: 100%;
            padding: 14px;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            font-size: 14px;
            font-family: inherit;
            transition: all 0.3s ease;
            background: #fafafa;
        }

        textarea {
            min-height: 140px;
            resize: vertical;
        }

        textarea:focus, input[type="file"]:focus {
            outline: none;
            border-color: #007aff;
            background: white;
            box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.1);
        }

        .method-selector {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }

        .method-btn {
            padding: 12px;
            background: #f3f4f6;
            border: 2px solid #f3f4f6;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            color: #6b7280;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .method-btn:hover {
            background: #e5e7eb;
            border-color: #e5e7eb;
        }

        .method-btn.active {
            background: white;
            color: #007aff;
            border-color: #007aff;
        }

        button.primary {
            padding: 16px 32px;
            background: linear-gradient(135deg, #007aff 0%, #00c6ff 100%);
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            margin-bottom: 12px;
            box-shadow: 0 4px 16px rgba(0, 122, 255, 0.3);
        }

        button.primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 24px rgba(0, 122, 255, 0.4);
        }
        
        button.primary:disabled {
            background: #adb5bd;
            box-shadow: none;
            cursor: not-allowed;
            transform: none;
        }

        button.danger {
            padding: 16px 32px;
            background: #ef4444;
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            box-shadow: 0 4px 16px rgba(239, 68, 68, 0.3);
        }

        button.danger:hover {
            background: #dc2626;
            transform: translateY(-2px);
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 16px;
            margin-top: 24px;
            padding: 24px;
            background: #f9fafb;
            border-radius: 12px;
            border: 2px solid #e5e7eb;
        }

        .stat-item {
            text-align: center;
            padding: 12px;
            background: white;
            border-radius: 10px;
        }

        .stat-label {
            font-size: 12px;
            color: #6b7280;
            margin-bottom: 8px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            background: linear-gradient(135deg, #007aff 0%, #00c6ff 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .stat-value.ok {
             background: linear-gradient(135deg, #10b981 0%, #14b8a6 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .stat-value.fail {
             background: linear-gradient(135deg, #ef4444 0%, #f87171 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        #flashScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 9999;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        
        #flashScreen.active {
            display: flex;
        }

        .flash-info {
            position: absolute;
            bottom: 30px;
            left: 50%; 
            transform: translateX(-50%);
            background: rgba(0,0,0,0.85);
            backdrop-filter: blur(10px);
            color: white;
            padding: 18px 32px;
            border-radius: 16px;
            font-size: 14px;
            font-weight: 500;
            z-index: 10000;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            text-align: center;
        }
        
        #receivedPreview {
            margin-top: 24px; 
            padding: 24px;
            background: #f9fafb;
            border-radius: 12px;
            min-height: 120px;
            border: 2px solid #e5e7eb;
        }

        #receivedImageCanvas {
            max-width: 100%;
            border-radius: 12px;
            display: none; 
            min-height: 50px; 
            background: #e5e7eb;
            image-rendering: pixelated;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        #receivedText {
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
            word-break: break-all;
            line-height: 1.6;
            color: #374151;
        }
        
        #downloadButton {
            display: none;
            margin-top: 20px;
            text-decoration: none;
            text-align: center;
        }

        .info-box {
            background: #e6f7ff;
            border: 2px solid #b3e0ff;
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 20px;
            color: #0056b3;
            font-size: 14px;
            line-height: 1.6;
        }

        .info-box strong {
            display: block;
            margin-bottom: 6px;
            font-size: 15px;
        }

        #cameraView {
            width: 100%;
            max-width: 400px;
            margin: 0 auto;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            display: block;
            background: #333;
        }
        
        .loader {
            width: 48px;
            height: 48px;
            border: 5px solid #FFF;
            border-bottom-color: transparent;
            border-radius: 50%;
            display: inline-block;
            box-sizing: border-box;
            animation: rotation 1s linear infinite;
            margin-bottom: 12px;
        }
        
        .loader-small {
            width: 20px;
            height: 20px;
            border: 3px solid #FFF;
            border-bottom-color: transparent;
            border-radius: 50%;
            display: none;
            box-sizing: border-box;
            animation: rotation 1s linear infinite;
        }
        
        button.primary:disabled .loader-small {
            display: inline-block;
        }

        @keyframes rotation {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        #confirmationOverlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 9998;
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            text-align: center;
            color: white;
            animation: fadeIn 0.3s ease;
        }
        
        #confirmationOverlay.active {
            display: flex;
        }
        
        #confirmationOverlay h2 {
            font-size: 28px;
            margin-bottom: 20px;
        }
        
        #confirmationOverlay button {
            width: 200px;
            margin: 10px;
        }
        
        .file-input-wrapper {
            border: 2px dashed #007aff;
            border-radius: 12px;
            padding: 30px;
            text-align: center;
            background: #f8faff;
            cursor: pointer;
            transition: background 0.2s ease;
        }
        
        .file-input-wrapper:hover {
            background: #e6f2ff;
        }
        
        .file-input-wrapper span {
            font-size: 16px;
            color: #007aff;
            font-weight: 500;
        }
        
        #fileName {
            font-weight: 600;
            color: #333;
            margin-top: 16px;
        }
        
        #inputFile, #inputImage {
            display: none;
        }

    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>PhotonSend</h1>
            <p>Transfer data using ‚ö° Turbo light speed</p>
        </div>

        <div class="mode-selector">
            <button class="mode-btn active" onclick="switchMode(event, 'send')">üì§ Send</button>
            <button class="mode-btn" onclick="switchMode(event, 'receive')">üì• Receive</button>
        </div>

        <div class="content">
            <div id="sendMode" class="section active">
                <div class="input-group">
                    <label>Data Type:</label>
                    <div class="method-selector">
                        <button class="method-btn active" onclick="switchDataType(event, 'text')">üìù Text</button>
                        <button class="method-btn" onclick="switchDataType(event, 'image')">üñºÔ∏è Image</button>
                        <button class="method-btn" onclick="switchDataType(event, 'file')">üìÅ File</button>
                    </div>
                </div>

                <div id="textInput" class="input-group">
                    <label>Enter Text:</label>
                    <textarea id="inputText" placeholder="Type your message here..."></textarea>
                </div>

                <div id="imageInput" class="input-group" style="display: none;">
                    <label>Select Image (custom spiral transfer):</label>
                    <label for="inputImage" class="file-input-wrapper">
                        <span>Click to select an image</span>
                        <div id="imageFileName"></div>
                    </label>
                    <input type="file" id="inputImage" accept="image/*" onchange="updateFileName('inputImage', 'imageFileName')">
                </div>
                
                <div id="fileInput" class="input-group" style="display: none;">
                    <label>Select File:</label>
                    <label for="inputFile" class="file-input-wrapper">
                        <span>Click to select any file</span>
                        <div id="fileName"></div>
                    </label>
                    <input type="file" id="inputFile" onchange="updateFileName('inputFile', 'fileName')">
                </div>

                <button id="startSendButton" class="primary" onclick="confirmTransmission()">
                    üöÄ Start Transmission
                    <span class="loader-small"></span>
                </button>

                <div id="sendStats" class="stats" style="display: none;">
                    <div class="stat-item">
                        <div class="stat-label">Size</div>
                        <div class="stat-value" id="dataSize">0 bytes</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Progress</div>
                        <div class="stat-value" id="progress">0%</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Packets</div>
                        <div class="stat-value" id="packetProgress">0 / 0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Time Left</div>
                        <div class="stat-value" id="timeRemaining">--</div>
                    </div>
                </div>
            </div>

            <div id="receiveMode" class="section">
                <div class="info-box">
                    <strong>üì± Setup Instructions:</strong>
                    1. Aim your camera at the center of the flashing screen.<br>
                    2. Press "Start Receiving" and wait for the "SYNC" signal.<br>
                    3. Keep devices stable during transfer.
                </div>

                <div id="colorReceive">
                    <button class="primary" id="startReceiveBtn" onclick="startColorReceive()">üìπ Start Receiving</button>
                    <button class="danger" id="stopReceiveBtn" onclick="stopReceiving()" style="display: none;">‚èπÔ∏è Stop</button>
                    
                    <div id="receiveLayout" style="display: none; flex-direction: column; gap: 20px; margin-top: 20px;">
                        <video id="cameraView" autoplay playsinline muted></video>
                        
                        <div id="receivedArea" style="width: 100%;">
                             <div id="receiveStats" class="stats">
                                <div class="stat-item">
                                    <div class="stat-label">Status</div>
                                    <div class="stat-value" id="receiveStatus" style="font-size: 18px;">Idle</div>
                                </div>
                                <div class="stat-item">
                                    <div class="stat-label">Packets</div>
                                    <div class="stat-value" id="receivedPackets">0 / 0</div>
                                </div>
                                <div class="stat-item">
                                    <div class="stat-label">Received</div>
                                    <div class="stat-value" id="receivedBits">0 bits</div>
                                </div>
                                <div class="stat-item">
                                    <div class="stat-label">Checksum</div>
                                    <div class="stat-value" id="checksumStatus" style="font-size: 18px;">--</div>
                                </div>
                            </div>
                            
                            <div id="receivedPreview">
                                <div class="stat-label">üìä Live Received Data:</div>
                                <div id="receivedText">Awaiting transmission...</div>
                                <canvas id="receivedImageCanvas"></canvas>
                                <a id="downloadButton" href="#" download class="primary">üì• Download File</a>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="confirmationOverlay">
        <div style="animation: slideIn 0.5s ease-out;">
            <h2>Ready to Send?</h2>
            <p style="margin-bottom: 30px; font-size: 16px; opacity: 0.8;">The screen will flash colors.<br>Ensure the receiver is ready.</p>
            <button class="primary" onclick="startTransmission()">‚úÖ Yes, Start Now</button>
            <button class="danger" onclick="cancelTransmission()">‚ùå Cancel</button>
        </div>
    </div>

    <div id="flashScreen">
        <div class="flash-info" id="flashInfo">
            <div id="flashLoader" class="loader"></div>
            <span id="flashInfoText">Preparing transmission...</span>
        </div>
    </div>

    <script>
        // ===================================================================
        // G L O B A L S
        // ===================================================================
        let currentMode = 'send';
        let currentDataType = 'text';
        let transmissionActive = false;
        let receivingActive = false;
        
        let bitStream = [];
        let currentBitIndex = 0;
        let receivedBits = [];
        let startTime = 0;
        
        let videoStream = null;
        let captureFrameId = null;
        let receiverState = 'IDLE'; // IDLE, WAITING_FOR_SYNC, RECEIVING, PROCESSING
        let receivedColors = [];
        let lastColorChangeTime = 0;
        let lastDetectedColor = 'white';
        let fullDataPayload = null;
        
        // ===================================================================
        // C O N S T A N T S
        // ===================================================================
        const SYMBOL_MS = 200; // Hard-coded speed: 200ms
        const PACKET_SIZE = 512; // 512 bytes per packet
        
        // Turbo Mode Colors (Hard-coded)
        const COLOR_00 = '#ff0000'; // Red
        const COLOR_01 = '#00ff00'; // Green
        const COLOR_10 = '#0000ff'; // Blue
        const COLOR_11 = '#ffff00'; // Yellow
        const COLOR_WHITE = '#ffffff';
        
        const START_SEQ = [COLOR_00, COLOR_01, COLOR_10, COLOR_11]; // R, G, B, Y
        const END_SEQ = [COLOR_11, COLOR_10, COLOR_01, COLOR_00]; // Y, B, G, R
        
        // ===================================================================
        // C R C 3 2   C H E C K S U M
        // ===================================================================
        const crc32Table = (function() {
            let table = new Uint32Array(256);
            for(let i = 0; i < 256; i++) {
                let c = i;
                for(let k = 0; k < 8; k++) {
                    c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
                }
                table[i] = c;
            }
            return table;
        })();
        
        function crc32(bytes) {
            let crc = 0xFFFFFFFF;
            for(let i = 0; i < bytes.length; i++) {
                crc = (crc >>> 8) ^ crc32Table[(crc ^ bytes[i]) & 0xFF];
            }
            return (crc ^ 0xFFFFFFFF) >>> 0;
        }

        // ===================================================================
        // D A T A   H A N D L I N G   ( B Y T E S / B I T S )
        // ===================================================================
        function stringToBytes(str) {
            // Use TextEncoder for UTF-8 support
            return new TextEncoder().encode(str);
        }

        function bytesToString(bytes) {
            // Use TextDecoder for UTF-8 support
            return new TextDecoder().decode(bytes);
        }

        function bytesToBits(bytes) {
            const bits = [];
            for (let i = 0; i < bytes.length; i++) {
                const byte = bytes[i];
                for (let j = 7; j >= 0; j--) {
                    bits.push((byte >> j) & 1);
                }
            }
            return bits;
        }

        function bitsToBytes(bits) {
            const bytes = new Uint8Array(Math.ceil(bits.length / 8));
            let byteIndex = 0;
            for (let i = 0; i < bits.length; i += 8) {
                let byte = 0;
                for (let j = 0; j < 8; j++) {
                    if (i + j < bits.length) {
                        byte = (byte << 1) | bits[i + j];
                    } else {
                        byte = byte << 1; // Pad with 0 if not enough bits
                    }
                }
                bytes[byteIndex++] = byte;
            }
            return bytes;
        }
        
        // Helper to convert number to a 4-byte array (for headers)
        function numToBytes(num) {
            return [
                (num >> 24) & 0xFF,
                (num >> 16) & 0xFF,
                (num >> 8) & 0xFF,
                num & 0xFF
            ];
        }
        
        // Helper to convert 4-byte array to number
        function bytesToNum(bytes) {
            return (bytes[0] << 24) | (bytes[1] << 16) | (bytes[2] << 8) | bytes[3];
        }
        
        // Helper to convert 2-byte array to number
        function bytesToNum16(bytes) {
            return (bytes[0] << 8) | bytes[1];
        }

        // ===================================================================
        // S E N D E R   L O G I C
        // ===================================================================

        function switchMode(event, mode) {
            currentMode = mode;
            document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
            event.currentTarget.classList.add('active');
            
            document.getElementById('sendMode').classList.toggle('active', mode === 'send');
            document.getElementById('receiveMode').classList.toggle('active', mode === 'receive');
            if (mode === 'receive') {
                stopReceiving(); // Stop any active receiving
            } else {
                stopReceiving(); // Also stop if switching away from receive
            }
        }

        function switchDataType(event, type) {
            currentDataType = type;
            document.querySelectorAll('.method-btn').forEach(btn => btn.classList.remove('active'));
            event.currentTarget.classList.add('active');

            document.getElementById('textInput').style.display = type === 'text' ? 'block' : 'none';
            document.getElementById('imageInput').style.display = type === 'image' ? 'block' : 'none';
            document.getElementById('fileInput').style.display = type === 'file' ? 'block' : 'none';
        }
        
        function updateFileName(inputId, elemId) {
            const file = document.getElementById(inputId).files[0];
            if (file) {
                document.getElementById(elemId).textContent = file.name;
            }
        }
        
        function loadImage(file) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.onerror = reject;
                img.src = URL.createObjectURL(file);
            });
        }
        
        async function fileToBytes(file) {
             return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(new Uint8Array(reader.result));
                reader.onerror = reject;
                reader.readAsArrayBuffer(file);
             });
        }

        async function prepareData() {
            let header, payloadBytes;

            try {
                if (currentDataType === 'text') {
                    const text = document.getElementById('inputText').value;
                    if (!text) throw new Error('Please enter some text');
                    header = { type: 'text' };
                    payloadBytes = stringToBytes(text);
                } 
                else if (currentDataType === 'image') {
                    const file = document.getElementById('inputImage').files[0];
                    if (!file) throw new Error('Please select an image');
                    
                    const img = await loadImage(file);
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    // For spiral, send raw pixels. Let's use a fixed reasonable size for demo.
                    // Or, let's just use its natural size, up to a limit.
                    let targetWidth = img.width;
                    let targetHeight = img.height;
                    const maxSize = 128; // Limit size for faster transfer
                    
                    if (targetWidth > maxSize || targetHeight > maxSize) {
                        if (targetWidth > targetHeight) {
                            targetHeight = Math.round(maxSize * (targetHeight / targetWidth));
                            targetWidth = maxSize;
                        } else {
                            targetWidth = Math.round(maxSize * (targetWidth / targetHeight));
                            targetHeight = maxSize;
                        }
                    }

                    canvas.width = targetWidth;
                    canvas.height = targetHeight;
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    
                    const imageData = ctx.getImageData(0, 0, targetWidth, targetHeight).data;
                    const rgbArray = [];
                    for (let i = 0; i < imageData.length; i += 4) {
                        rgbArray.push(imageData[i]);   // R
                        rgbArray.push(imageData[i + 1]); // G
                        rgbArray.push(imageData[i + 2]); // B
                    }
                    
                    header = { type: 'image', width: targetWidth, height: targetHeight };
                    payloadBytes = new Uint8Array(rgbArray);
                }
                else { // 'file'
                    const file = document.getElementById('inputFile').files[0];
                    if (!file) throw new Error('Please select a file');
                    header = { type: 'file', name: file.name, mime: file.type || 'application/octet-stream' };
                    payloadBytes = await fileToBytes(file);
                }
            } catch (err) {
                alert(err.message);
                return null;
            }

            // --- New Production Pipeline ---
            
            // 1. Create header string
            const headerString = JSON.stringify(header);
            const headerBytes = stringToBytes(headerString);
            
            // 2. Compress payload
            const compressedPayload = pako.deflate(payloadBytes);
            
            // 3. Combine: [header_length (2 bytes)] + [header_data] + [compressed_payload]
            const fullData = new Uint8Array(2 + headerBytes.length + compressedPayload.length);
            fullData[0] = (headerBytes.length >> 8) & 0xFF; // Header length high byte
            fullData[1] = headerBytes.length & 0xFF;        // Header length low byte
            fullData.set(headerBytes, 2);
            fullData.set(compressedPayload, 2 + headerBytes.length);
            
            // 4. Calculate Checksum
            const checksum = crc32(fullData);
            
            // 5. Packetize
            const totalPackets = Math.ceil(fullData.length / PACKET_SIZE);
            const allPackets = [];
            
            // 5a. Main Header Packet
            const mainHeader = {
                totalBytes: fullData.length,
                totalPackets: totalPackets,
                checksum: checksum
            };
            const mainHeaderString = JSON.stringify(mainHeader);
            const mainHeaderBytes = stringToBytes(mainHeaderString);
            // Add a "packet header" to the main header packet itself
            // [Packet Index (2 bytes, 0=main)] + [Data Length (2 bytes)] + [Data]
            const mainHeaderPacket = new Uint8Array(4 + mainHeaderBytes.length);
            mainHeaderPacket[0] = 0; // Packet 0
            mainHeaderPacket[1] = 0; // Packet 0
            mainHeaderPacket[2] = (mainHeaderBytes.length >> 8) & 0xFF; // Length
            mainHeaderPacket[3] = mainHeaderBytes.length & 0xFF;        // Length
            mainHeaderPacket.set(mainHeaderBytes, 4);
            allPackets.push(mainHeaderPacket);

            // 5b. Data Packets
            for (let i = 0; i < totalPackets; i++) {
                const chunk = fullData.slice(i * PACKET_SIZE, (i + 1) * PACKET_SIZE);
                const packetIndex = i + 1; // 1-based index for data packets
                
                // [Packet Index (2 bytes)] + [Data Length (2 bytes)] + [Data]
                const packet = new Uint8Array(4 + chunk.length);
                packet[0] = (packetIndex >> 8) & 0xFF;
                packet[1] = packetIndex & 0xFF;
                packet[2] = (chunk.length >> 8) & 0xFF;
                packet[3] = chunk.length & 0xFF;
                packet.set(chunk, 4);
                allPackets.push(packet);
            }
            
            // 6. Concatenate all packets into one giant byte array
            const totalLength = allPackets.reduce((sum, p) => sum + p.length, 0);
            const finalByteArray = new Uint8Array(totalLength);
            let offset = 0;
            for (const packet of allPackets) {
                finalByteArray.set(packet, offset);
                offset += packet.length;
            }
            
            // 7. Convert to bitstream
            bitStream = bytesToBits(finalByteArray);
            
            document.getElementById('dataSize').textContent = `${fullData.length} bytes`;
            document.getElementById('packetProgress').textContent = `0 / ${totalPackets}`;
            
            return { totalPackets, fullDataLength: fullData.length };
        }

        async function confirmTransmission() {
            document.getElementById('startSendButton').disabled = true;
            document.getElementById('startSendButton').querySelector('.loader-small').style.display = 'inline-block';
            
            const prepResult = await prepareData();
            
            document.getElementById('startSendButton').disabled = false;
            document.getElementById('startSendButton').querySelector('.loader-small').style.display = 'none';

            if (!prepResult) return; // Error handled in prepareData
            
            document.getElementById('confirmationOverlay').classList.add('active');
        }
        
        function cancelTransmission() {
            document.getElementById('confirmationOverlay').classList.remove('active');
        }

        function startTransmission() {
            if (transmissionActive) return;
            
            document.getElementById('confirmationOverlay').classList.remove('active');
            
            transmissionActive = true;
            currentBitIndex = 0;
            startTime = Date.now();
            
            const flashScreen = document.getElementById('flashScreen');
            const flashInfoText = document.getElementById('flashInfoText');
            const flashLoader = document.getElementById('flashLoader');
            flashScreen.classList.add('active');
            flashLoader.style.display = 'block';
            flashInfoText.textContent = 'Starting handshake...';

            document.getElementById('sendStats').style.display = 'grid';

            // --- TRANSMISSION LOOP ---
            let symbolIndex = 0;
            
            function transmitNext() {
                if (!transmissionActive) {
                    flashScreen.style.backgroundColor = COLOR_WHITE;
                    flashScreen.classList.remove('active');
                    return;
                }
                
                let color;
                let isData = false;
                
                // 1. Start Sequence
                if (symbolIndex < START_SEQ.length) {
                    color = START_SEQ[symbolIndex];
                    flashInfoText.textContent = `Sending SYNC (${symbolIndex + 1}/${START_SEQ.length})`;
                }
                // 2. Data
                else if (currentBitIndex < bitStream.length) {
                    flashLoader.style.display = 'none';
                    isData = true;
                    
                    const bit1 = bitStream[currentBitIndex];
                    const bit2 = (currentBitIndex + 1 < bitStream.length) ? bitStream[currentBitIndex + 1] : 0; // Pad last bit
                    
                    if (bit1 === 0 && bit2 === 0) color = COLOR_00;
                    else if (bit1 === 0 && bit2 === 1) color = COLOR_01;
                    else if (bit1 === 1 && bit2 === 0) color = COLOR_10;
                    else color = COLOR_11;
                    
                    currentBitIndex += 2; // Always advance by 2 (turbo mode)
                }
                // 3. End Sequence
                else if (symbolIndex < START_SEQ.length + 1 + END_SEQ.length) { // +1 for the extra "data" symbol
                    const endSeqIndex = symbolIndex - START_SEQ.length - 1;
                    color = END_SEQ[endSeqIndex];
                    flashInfoText.textContent = `Sending END (${endSeqIndex + 1}/${END_SEQ.length})`;
                }
                // 4. Done
                else {
                    flashScreen.style.backgroundColor = COLOR_01; // Green for success
                    flashInfoText.textContent = '‚úÖ Transmission Complete!';
                    setTimeout(() => {
                        flashScreen.classList.remove('active');
                        transmissionActive = false;
                    }, 2000);
                    return;
                }
                
                // Flash the color
                flashScreen.style.backgroundColor = color;
                
                // Update stats if in data phase
                if (isData) {
                    const progress = ((currentBitIndex / bitStream.length) * 100);
                    document.getElementById('progress').textContent = progress.toFixed(1) + '%';
                    
                    const elapsed = Date.now() - startTime;
                    const bitsPerMs = currentBitIndex / elapsed;
                    const remaining = bitsPerMs > 0 ? (bitStream.length - currentBitIndex) / bitsPerMs : 0;
                    document.getElementById('timeRemaining').textContent = Math.ceil(remaining / 1000) + 's';
                    
                    flashInfoText.textContent = `Symbol ${symbolIndex - START_SEQ.length} - ${progress.toFixed(1)}%`;
                }
                
                symbolIndex++;

                // Schedule the "white" separator flash
                setTimeout(() => {
                    flashScreen.style.backgroundColor = COLOR_WHITE;
                    // Schedule the next color
                    setTimeout(transmitNext, SYMBOL_MS / 2);
                }, SYMBOL_MS / 2);
            }

            transmitNext();
        }

        // ===================================================================
        // R E C E I V E R   L O G I C
        // ===================================================================

        async function startColorReceive() {
            if (receivingActive) return;

            const video = document.getElementById('cameraView');
            document.getElementById('startReceiveBtn').style.display = 'none';
            document.getElementById('stopReceiveBtn').style.display = 'block';
            document.getElementById('receiveLayout').style.display = 'flex';
            
            try {
                if (videoStream) {
                    videoStream.getTracks().forEach(track => track.stop());
                }

                videoStream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: 'environment' } 
                });
                video.srcObject = videoStream;
                video.onloadedmetadata = () => video.play();
                
                receivingActive = true;
                resetReceiverState();
                
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d', { willReadFrequently: true });
                
                function captureFrame() {
                    if (!receivingActive) return;

                    if (video.readyState < video.HAVE_METADATA) {
                        captureFrameId = requestAnimationFrame(captureFrame);
                        return;
                    }

                    if (canvas.width !== video.videoWidth) {
                        canvas.width = video.videoWidth;
                        canvas.height = video.videoHeight;
                    }
                    
                    // Sample a 50x50 area from the center
                    const sampleSize = 50;
                    const sx = (canvas.width / 2) - (sampleSize / 2);
                    const sy = (canvas.height / 2) - (sampleSize / 2);
                    
                    ctx.drawImage(video, sx, sy, sampleSize, sampleSize, 0, 0, sampleSize, sampleSize);
                    const imageData = ctx.getImageData(0, 0, sampleSize, sampleSize).data;
                    
                    let r = 0, g = 0, b = 0;
                    const pixelCount = imageData.length / 4;
                    for (let i = 0; i < imageData.length; i += 4) {
                        r += imageData[i];
                        g += imageData[i + 1];
                        b += imageData[i + 2];
                    }
                    r /= pixelCount;
                    g /= pixelCount;
                    b /= pixelCount;

                    // --- Color Detection ---
                    let detectedColor = 'unknown';
                    
                    if (r > 180 && g > 180 && b > 180) detectedColor = COLOR_WHITE;
                    else if (r > 150 && g > 150 && b < 100) detectedColor = COLOR_11; // Yellow
                    else if (g > 150 && r < 100 && b < 100) detectedColor = COLOR_01; // Green
                    else if (r > 150 && g < 100 && b < 100) detectedColor = COLOR_00; // Red
                    else if (b > 150 && r < 100 && g < 100) detectedColor = COLOR_10; // Blue
                    
                    // --- State Machine ---
                    const now = Date.now();
                    if (detectedColor !== lastDetectedColor && detectedColor !== 'unknown') {
                        // Only register a new color if it's not white and it's different
                        if (detectedColor !== COLOR_WHITE) {
                            processDetectedColor(detectedColor);
                        }
                        lastDetectedColor = detectedColor;
                        lastColorChangeTime = now;
                    }

                    captureFrameId = requestAnimationFrame(captureFrame);
                }

                captureFrame();
                
            } catch (err) {
                alert('Camera access denied: ' + err.message);
                stopReceiving();
            }
        }
        
        function processDetectedColor(color) {
            receivedColors.push(color);
            if (receivedColors.length > 4) receivedColors.shift(); // Keep only last 4
            
            if (receiverState === 'WAITING_FOR_SYNC') {
                if (arrayEquals(receivedColors, START_SEQ)) {
                    console.log('START SYNC DETECTED!');
                    receiverState = 'RECEIVING';
                    receivedBits = [];
                    document.getElementById('receiveStatus').textContent = 'Receiving...';
                    document.getElementById('receivedText').textContent = '';
                }
            }
            else if (receiverState === 'RECEIVING') {
                if (arrayEquals(receivedColors, END_SEQ)) {
                    console.log('END SYNC DETECTED!');
                    receiverState = 'PROCESSING';
                    document.getElementById('receiveStatus').textContent = 'Processing...';
                    stopReceiving(true); // Stop camera, but keep processing
                    processReceivedData();
                    return; // Don't add data bits
                }
                
                // Add data bits
                if (color === COLOR_00) receivedBits.push(0, 0);
                else if (color === COLOR_01) receivedBits.push(0, 1);
                else if (color === COLOR_10) receivedBits.push(1, 0);
                else if (color === COLOR_11) receivedBits.push(1, 1);
                
                document.getElementById('receivedBits').textContent = `${receivedBits.length} bits`;
            }
        }
        
        async function processReceivedData() {
            try {
                const receivedBytes = bitsToBytes(receivedBits);
                
                // --- Depacketize ---
                let offset = 0;
                
                // 1. Read Main Header Packet
                const mainHeaderIndex = bytesToNum16([receivedBytes[offset], receivedBytes[offset+1]]);
                const mainHeaderLength = bytesToNum16([receivedBytes[offset+2], receivedBytes[offset+3]]);
                offset += 4;
                
                if (mainHeaderIndex !== 0) throw new Error('Invalid header packet');
                
                const mainHeaderBytes = receivedBytes.slice(offset, offset + mainHeaderLength);
                const mainHeader = JSON.parse(bytesToString(mainHeaderBytes));
                offset += mainHeaderLength;
                
                const { totalBytes, totalPackets, checksum: expectedChecksum } = mainHeader;
                
                document.getElementById('receivedPackets').textContent = `0 / ${totalPackets}`;
                document.getElementById('checksumStatus').textContent = 'Verifying...';
                
                // 2. Reassemble Data
                fullDataPayload = new Uint8Array(totalBytes);
                let receivedPacketCount = 0;
                
                while (offset < receivedBytes.length && receivedPacketCount < totalPackets) {
                    if (offset + 4 > receivedBytes.length) break; // Not enough data for packet header
                    
                    const packetIndex = bytesToNum16([receivedBytes[offset], receivedBytes[offset+1]]);
                    const packetLength = bytesToNum16([receivedBytes[offset+2], receivedBytes[offset+3]]);
                    offset += 4;
                    
                    if (offset + packetLength > receivedBytes.length) break; // Incomplete packet
                    
                    const chunk = receivedBytes.slice(offset, offset + packetLength);
                    offset += packetLength;
                    
                    const dataOffset = (packetIndex - 1) * PACKET_SIZE;
                    fullDataPayload.set(chunk, dataOffset);
                    
                    receivedPacketCount++;
                    document.getElementById('receivedPackets').textContent = `${receivedPacketCount} / ${totalPackets}`;
                }
                
                if (receivedPacketCount !== totalPackets) {
                    throw new Error(`Packet loss! Got ${receivedPacketCount}/${totalPackets}`);
                }
                
                // 3. Verify Checksum
                const calculatedChecksum = crc32(fullDataPayload);
                
                if (calculatedChecksum !== expectedChecksum) {
                    document.getElementById('checksumStatus').classList.add('fail');
                    document.getElementById('checksumStatus').textContent = 'FAIL!';
                    throw new Error(`Checksum mismatch! Data is corrupt. Expected ${expectedChecksum}, got ${calculatedChecksum}`);
                }
                
                document.getElementById('checksumStatus').classList.remove('fail');
                document.getElementById('checksumStatus').classList.add('ok');
                document.getElementById('checksumStatus').textContent = 'OK!';
                
                // 4. Decompress and Handle
                handleData(fullDataPayload);
                
            } catch (err) {
                document.getElementById('receivedText').textContent = `Error: ${err.message}`;
                document.getElementById('checksumStatus').classList.add('fail');
                document.getElementById('checksumStatus').textContent = 'Error';
                console.error(err);
            }
        }
        
        function handleData(fullData) {
            try {
                // 1. Parse header
                const headerLength = bytesToNum16([fullData[0], fullData[1]]);
                const headerBytes = fullData.slice(2, 2 + headerLength);
                const header = JSON.parse(bytesToString(headerBytes));
                
                // 2. Decompress payload
                const compressedPayload = fullData.slice(2 + headerLength);
                const payloadBytes = pako.inflate(compressedPayload);
                
                document.getElementById('receiveStatus').textContent = 'Complete!';

                // 3. Handle based on type
                if (header.type === 'text') {
                    const text = bytesToString(payloadBytes);
                    document.getElementById('receivedText').textContent = text;
                }
                else if (header.type === 'file') {
                    const blob = new Blob([payloadBytes], { type: header.mime });
                    const url = URL.createObjectURL(blob);
                    
                    const a = document.getElementById('downloadButton');
                    a.href = url;
                    a.download = header.name;
                    a.style.display = 'block';
                    
                    document.getElementById('receivedText').textContent = `‚úÖ File Received: ${header.name}`;
                }
                else if (header.type === 'image') {
                    document.getElementById('receivedText').textContent = `‚úÖ Image Received: ${header.width}x${header.height}. Rendering...`;
                    renderImageSpiral(payloadBytes, header.width, header.height);
                }
                
            } catch (err) {
                document.getElementById('receivedText').textContent = `Error processing data: ${err.message}`;
                console.error(err);
            }
        }
        
        async function renderImageSpiral(pixelData, width, height) {
            const canvas = document.getElementById('receivedImageCanvas');
            canvas.width = width;
            canvas.height = height;
            canvas.style.display = 'block';
            const ctx = canvas.getContext('2d');
            const imageData = ctx.createImageData(width, height);
            const data = imageData.data;
            
            let x = Math.floor(width / 2);
            let y = Math.floor(height / 2);
            let dx = 1;
            let dy = 0;
            let segmentLength = 1;
            let segmentPassed = 0;
            let pixelIndex = 0;

            document.getElementById('receivedText').textContent = 'Rendering image...';
            
            function drawNextPixel() {
                if (pixelIndex >= (width * height)) {
                    document.getElementById('receivedText').textContent = '‚úÖ Image Render Complete!';
                    return;
                }
                
                // Check bounds
                if (x >= 0 && x < width && y >= 0 && y < height) {
                    const dataIndex = (y * width + x) * 4;
                    const pixelDataIndex = pixelIndex * 3;
                    
                    data[dataIndex]     = pixelData[pixelDataIndex];
                    data[dataIndex + 1] = pixelData[pixelDataIndex + 1];
                    data[dataIndex + 2] = pixelData[pixelDataIndex + 2];
                    data[dataIndex + 3] = 255;
                    
                    pixelIndex++;
                }

                x += dx;
                y += dy;
                segmentPassed++;

                if (segmentPassed === segmentLength) {
                    segmentPassed = 0;
                    // Rotate 90 degrees
                    let temp = dx;
                    dx = -dy;
                    dy = temp;
                    // Increase segment length every 2 turns
                    if (dy === 0) {
                        segmentLength++;
                    }
                }
                
                // Batch update canvas
                if (pixelIndex % 100 === 0) {
                    ctx.putImageData(imageData, 0, 0);
                    requestAnimationFrame(drawNextPixel);
                } else {
                    drawNextPixel(); // Continue sync
                }
            }
            
            // Start drawing
            ctx.fillStyle = '#333';
            ctx.fillRect(0, 0, width, height);
            drawNextPixel();
        }

        function stopReceiving(isProcessing = false) {
            receivingActive = false;
            if (captureFrameId) {
                cancelAnimationFrame(captureFrameId);
                captureFrameId = null;
            }
            
            if (videoStream) {
                videoStream.getTracks().forEach(track => track.stop());
                videoStream = null;
            }
            
            if (!isProcessing) {
                resetReceiverState();
                document.getElementById('startReceiveBtn').style.display = 'block';
                document.getElementById('stopReceiveBtn').style.display = 'none';
                document.getElementById('receiveLayout').style.display = 'none';
            }
        }
        
        function resetReceiverState() {
            receiverState = 'WAITING_FOR_SYNC';
            receivedBits = [];
            receivedColors = [];
            fullDataPayload = null;
            document.getElementById('receiveStatus').textContent = 'Waiting for SYNC...';
            document.getElementById('receivedBits').textContent = '0 bits';
            document.getElementById('receivedPackets').textContent = '0 / 0';
            document.getElementById('checksumStatus').textContent = '--';
            document.getElementById('checksumStatus').classList.remove('ok', 'fail');
            document.getElementById('receivedText').textContent = 'Awaiting transmission...';
            document.getElementById('receivedImageCanvas').style.display = 'none';
            document.getElementById('downloadButton').style.display = 'none';
        }
        
        function arrayEquals(a, b) {
            return a.length === b.length && a.every((val, index) => val === b[index]);
        }

        // ===================================================================
        // E V E N T   L I S T E N E R S
        // ===================================================================
        window.addEventListener('beforeunload', () => {
            transmissionActive = false;
            stopReceiving();
        });
    </script>
</body>
</html>

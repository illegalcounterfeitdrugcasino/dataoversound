<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HyperLight Data Transfer</title>
    <style>
        :root {
            --bg-primary: #121212;
            --bg-secondary: #1e1e1e;
            --bg-tertiary: #2a2a2a;
            --text-primary: #e0e0e0;
            --text-secondary: #a0a0a0;
            --accent-primary: #00aaff;
            --accent-secondary: #aa00ff;
            --success: #00ffaa;
            --error: #ff4466;
            --warning: #ffaa00;
            --border-color: #3a3a3a;
            --shadow-color: rgba(0, 0, 0, 0.5);
            --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
        }

        [data-theme="light"] {
            --bg-primary: #f4f5f7;
            --bg-secondary: #ffffff;
            --bg-tertiary: #e9ecef;
            --text-primary: #212529;
            --text-secondary: #6c757d;
            --accent-primary: #007bff;
            --accent-secondary: #6f42c1;
            --success: #28a745;
            --error: #dc3545;
            --warning: #ffc107;
            --border-color: #dee2e6;
            --shadow-color: rgba(0, 0, 0, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-family);
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            transition: background 0.3s, color 0.3s;
        }

        .container {
            background: var(--bg-secondary);
            border-radius: 24px;
            box-shadow: 0 25px 80px var(--shadow-color);
            max-width: 1000px;
            width: 100%;
            overflow: hidden;
            border: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
        }

        .header {
            background: linear-gradient(135deg, var(--accent-primary) 0%, var(--accent-secondary) 100%);
            padding: 25px;
            text-align: center;
            color: white;
            position: relative;
        }

        .header h1 {
            font-size: 2rem;
            font-weight: 700;
        }
        
        #theme-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            font-size: 1.2rem;
            cursor: pointer;
            transition: background 0.2s;
        }
        #theme-toggle:hover { background: rgba(255,255,255,0.4); }

        .mode-selector {
            display: flex;
            background: var(--bg-tertiary);
            padding: 8px;
            gap: 8px;
        }

        .mode-btn {
            flex: 1;
            padding: 16px;
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: 12px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            color: var(--text-secondary);
        }
        .mode-btn.active {
            background: linear-gradient(135deg, var(--accent-primary) 0%, var(--accent-secondary) 100%);
            color: white;
            border-color: transparent;
            box-shadow: 0 4px 16px rgba(0, 170, 255, 0.3);
        }

        .content { padding: 25px; }
        .section { display: none; }
        .section.active { display: block; animation: fadeIn 0.5s; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

        .input-group { margin-bottom: 20px; }

        label {
            display: block;
            margin-bottom: 10px;
            font-weight: 600;
            color: var(--text-primary);
            font-size: 0.9rem;
        }

        .info-badge {
            display: inline-block;
            background: var(--warning);
            color: #121212;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 700;
            margin-left: 8px;
            text-transform: uppercase;
        }
        
        input, select, textarea {
            width: 100%;
            padding: 14px;
            border: 2px solid var(--border-color);
            border-radius: 12px;
            font-size: 1rem;
            font-family: inherit;
            transition: all 0.3s ease;
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        textarea { min-height: 120px; resize: vertical; }
        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: var(--accent-primary);
            background: var(--bg-secondary);
        }

        button.primary {
            padding: 16px 32px;
            background: linear-gradient(135deg, var(--accent-primary) 0%, var(--accent-secondary) 100%);
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            box-shadow: 0 4px 16px rgba(0, 170, 255, 0.3);
        }
        button.primary:hover { transform: translateY(-2px); box-shadow: 0 6px 24px rgba(0, 170, 255, 0.4); }
        button.primary:disabled { background: var(--text-secondary); cursor: not-allowed; transform: none; box-shadow: none; }
        
        button.secondary {
            padding: 14px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 2px solid var(--border-color);
            border-radius: 12px;
        }
        button.secondary:hover { border-color: var(--accent-primary); }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
        }
        
        .progress-bar {
            width: 100%;
            height: 12px;
            background: var(--bg-tertiary);
            border-radius: 6px;
            overflow: hidden;
            margin-top: 10px;
        }
        .progress-bar-inner {
            width: 0%;
            height: 100%;
            background: linear-gradient(135deg, var(--accent-primary) 0%, var(--accent-secondary) 100%);
            transition: width 0.2s linear;
        }

        .stats {
            margin-top: 20px;
            padding: 20px;
            background: var(--bg-tertiary);
            border-radius: 12px;
        }
        .stat-item {
            display: flex;
            justify-content: space-between;
            font-size: 0.9rem;
            margin-bottom: 8px;
        }
        .stat-label { color: var(--text-secondary); }
        .stat-value { font-weight: 600; }

        #flashScreen {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 9999;
            display: none;
            background: #000;
        }
        #flashScreen.active { display: block; }
        
        .flash-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            width: 100%; height: 100%;
        }
        .flash-quadrant { width: 100%; height: 100%; }
        
        .flash-info {
            position: fixed;
            bottom: 30px; left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.85);
            backdrop-filter: blur(10px);
            color: white;
            padding: 18px 32px;
            border-radius: 16px;
            font-size: 1rem;
            font-weight: 500;
            z-index: 10000;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            text-align: center;
        }
        
        #receiver-view {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }
        #camera-container {
            flex: 1;
            min-width: 300px;
            position: relative;
            background: var(--bg-tertiary);
            border-radius: 12px;
            overflow: hidden;
            border: 2px solid var(--border-color);
        }
        #cameraView {
            width: 100%;
            height: auto;
            display: block;
            transform: scaleX(-1); /* Mirror view */
        }
        #reticle {
            position: absolute;
            top: 50%; left: 50%;
            width: 50px; height: 50px;
            border: 2px solid rgba(255,255,255,0.8);
            transform: translate(-50%, -50%);
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
            background: rgba(0,0,0,0.2);
            border-radius: 4px;
        }
        #receiver-output {
            flex: 1;
            min-width: 300px;
        }
        #log-area {
            height: 150px;
            background: var(--bg-tertiary);
            border: 2px solid var(--border-color);
            border-radius: 12px;
            padding: 10px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.8rem;
            overflow-y: scroll;
            margin-top: 10px;
        }
        .log-entry {
            margin-bottom: 4px;
            word-break: break-all;
        }
        .log-success { color: var(--success); }
        .log-error { color: var(--error); }
        .log-info { color: var(--text-secondary); }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>HyperLight Transfer</h1>
            <p>Data transmission via modulated light</p>
            <button id="theme-toggle" title="Toggle Theme">◐</button>
        </div>

        <div class="mode-selector">
            <button class="mode-btn active" onclick="UI.switchMode('send')">📤 Send</button>
            <button class="mode-btn" onclick="UI.switchMode('receive')">📥 Receive</button>
        </div>

        <div class="content">
            <div id="sendMode" class="section active">
                <div class="input-group">
                    <label for="fileInput">Select File to Transmit:</label>
                    <input type="file" id="fileInput" onchange="UI.handleFileSelect(this.files)">
                </div>
                
                <div class="grid">
                    <div class="input-group">
                        <label for="protocolSelect">Transmission Protocol:</label>
                        <select id="protocolSelect" onchange="UI.updateProtocolInfo()">
                            <option value="STANDARD">Standard (2 Colors, ~10 B/s)</option>
                            <option value="TURBO">Turbo (4 Colors, ~20 B/s)</option>
                            <option value="HYPER">Hyper (8 Colors, ~30 B/s)</option>
                            <option value="SINGULARITY">Singularity (4 Quadrants, ~80 B/s)</option>
                        </select>
                    </div>
                     <div class="input-group">
                        <label for="symbolRate">Symbol Rate (ms):</label>
                        <input type="number" id="symbolRate" value="100" min="20" max="500" step="10">
                    </div>
                </div>

                <div id="protocolInfo" class="stats" style="margin-top:0;">
                    <p>Select a protocol to see details.</p>
                </div>
                
                <button id="startTransmissionBtn" class="primary" onclick="Transmitter.start()" disabled>🚀 Start Transmission</button>
                
                <div id="send-progress" class="stats" style="display: none;">
                     <label>Transmission Progress</label>
                     <div class="progress-bar">
                         <div id="send-progress-bar" class="progress-bar-inner"></div>
                     </div>
                     <div class="stat-item" style="margin-top: 10px;">
                         <span class="stat-label">Status:</span>
                         <span id="sendStatus" class="stat-value">Idle</span>
                     </div>
                     <div class="stat-item">
                         <span class="stat-label">Time Remaining:</span>
                         <span id="sendTime" class="stat-value">--</span>
                     </div>
                </div>
            </div>

            <div id="receiveMode" class="section">
                <div id="receiver-view">
                    <div id="camera-container">
                        <video id="cameraView" autoplay playsinline muted></video>
                        <div id="reticle"></div>
                    </div>
                    <div id="receiver-output">
                        <div class="grid" style="align-items: flex-start;">
                            <button id="startReceiverBtn" class="primary" onclick="Receiver.start()">📹 Start Camera</button>
                            <button id="calibrateBtn" class="secondary" onclick="Receiver.startCalibration()" disabled>🔬 Calibrate Colors</button>
                        </div>
                         <div id="receive-progress" class="stats">
                             <label>Reception Progress</label>
                             <div class="progress-bar">
                                 <div id="receive-progress-bar" class="progress-bar-inner"></div>
                             </div>
                             <div class="stat-item" style="margin-top: 10px;">
                                 <span class="stat-label">Status:</span>
                                 <span id="receiveStatus" class="stat-value">Idle</span>
                             </div>
                             <div class="stat-item">
                                <span class="stat-label">Downloaded:</span>
                                <span id="downloaded" class="stat-value">0 Bytes</span>
                            </div>
                         </div>
                    </div>
                </div>
                <div>
                    <label style="margin-top: 20px;">Receiver Log:</label>
                    <div id="log-area"></div>
                </div>
                <a id="downloadLink" style="display:none"></a>
            </div>
        </div>
    </div>

    <div id="flashScreen">
        <div id="flashInfo" class="flash-info">Preparing Transmission...</div>
    </div>

    <script>
    // --- CRC32 Checksum Utility ---
    const crc32 = (function() {
        let table;
        function makeTable() {
            let c;
            table = [];
            for (let n = 0; n < 256; n++) {
                c = n;
                for (let k = 0; k < 8; k++) {
                    c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
                }
                table[n] = c;
            }
        }
        return function(buf) {
            if (!table) makeTable();
            let crc = -1;
            for (let i = 0; i < buf.length; i++) {
                crc = (crc >>> 8) ^ table[(crc ^ buf[i]) & 0xFF];
            }
            return (crc ^ -1) >>> 0;
        };
    })();

    // --- Core Application State ---
    const appState = {
        mode: 'send',
        file: null,
        fileBuffer: null,
        protocol: 'STANDARD',
        isTransmitting: false,
        isReceiving: false,
        isCalibrating: false,
        calibratedColors: {},
        packets: [],
        receivedPackets: {},
        totalPackets: 0,
        metadata: null,
        startTime: 0,
        theme: 'dark'
    };

    // --- Communication Protocol Definition ---
    const PROTOCOLS = {
        'STANDARD': {
            name: 'Standard',
            bitsPerSymbol: 1,
            colors: ['#ff0000', '#0000ff'], // Red (0), Blue (1)
            description: 'Basic 1-bit encoding. Slow but reliable in most lighting conditions.'
        },
        'TURBO': {
            name: 'Turbo',
            bitsPerSymbol: 2,
            colors: ['#ff0000', '#00ff00', '#0000ff', '#ffff00'], // R(00), G(01), B(10), Y(11)
            description: 'Uses 4 colors to double the data rate. Requires good color distinction.'
        },
        'HYPER': {
            name: 'Hyper',
            bitsPerSymbol: 3,
            colors: ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#00ffff', '#ff00ff', '#ffffff', '#ff8800'], // R,G,B,Y,C,M,W,Orange
            description: 'Uses 8 colors for 3 bits/symbol. Fast but very sensitive to screen/camera quality.'
        },
        'SINGULARITY': {
            name: 'Singularity',
            bitsPerSymbol: 8, // 4 quadrants * 2 bits/color
            colors: PROTOCOLS.TURBO.colors, // Uses Turbo color set in each quadrant
            isSpatial: true,
            description: 'EXPERIMENTAL: Uses 4 screen quadrants simultaneously for extreme speed. Requires precise alignment.'
        }
    };
    const PACKET_TYPE = { METADATA: 1, DATA: 2, EOT: 3 };
    const PREAMBLE = [ '#000000', '#ffffff', '#000000', '#ffffff' ];
    const PACKET_SIZE = 512; // bytes

    // --- UI Management ---
    const UI = {
        init() {
            document.getElementById('theme-toggle').addEventListener('click', this.toggleTheme);
            this.updateProtocolInfo();
            this.setTheme(localStorage.getItem('theme') || 'dark');
        },
        toggleTheme() {
            appState.theme = (appState.theme === 'dark') ? 'light' : 'dark';
            UI.setTheme(appState.theme);
        },
        setTheme(theme) {
            document.documentElement.setAttribute('data-theme', theme);
            localStorage.setItem('theme', theme);
            appState.theme = theme;
        },
        switchMode(mode) {
            appState.mode = mode;
            document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            document.getElementById('sendMode').classList.toggle('active', mode === 'send');
            document.getElementById('receiveMode').classList.toggle('active', mode === 'receive');
            if (mode === 'send' && appState.isReceiving) Receiver.stop();
            if (mode === 'receive' && appState.isTransmitting) Transmitter.stop();
        },
        handleFileSelect(files) {
            if (files.length === 0) return;
            appState.file = files[0];
            const reader = new FileReader();
            reader.onload = e => {
                appState.fileBuffer = new Uint8Array(e.target.result);
                document.getElementById('startTransmissionBtn').disabled = false;
                this.log(`Selected file: ${appState.file.name} (${(appState.fileBuffer.length / 1024).toFixed(2)} KB)`, 'info', 'log-area-send'); // Imaginary send log
            };
            reader.readAsArrayBuffer(appState.file);
        },
        updateProtocolInfo() {
            const protocolId = document.getElementById('protocolSelect').value;
            appState.protocol = protocolId;
            const protocol = PROTOCOLS[protocolId];
            const infoDiv = document.getElementById('protocolInfo');
            infoDiv.innerHTML = `<strong>${protocol.name} Mode:</strong> ${protocol.description}`;
        },
        log(message, type = 'info', areaId = 'log-area') {
            const logArea = document.getElementById(areaId);
            if (!logArea) return;
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logArea.appendChild(entry);
            logArea.scrollTop = logArea.scrollHeight;
        },
        updateProgress(id, percentage) {
            const bar = document.getElementById(id);
            if (bar) bar.style.width = `${percentage}%`;
        },
        setStatus(id, text) {
            const statusEl = document.getElementById(id);
            if (statusEl) statusEl.textContent = text;
        },
        playSound(type) {
            const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            
            gainNode.gain.setValueAtTime(0, audioCtx.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.3, audioCtx.currentTime + 0.01);
            
            if (type === 'start') {
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(440, audioCtx.currentTime);
            } else if (type === 'end') {
                oscillator.type = 'triangle';
                oscillator.frequency.setValueAtTime(880, audioCtx.currentTime);
                oscillator.frequency.linearRampToValueAtTime(440, audioCtx.currentTime + 0.2);
            } else if (type === 'error') {
                oscillator.type = 'square';
                oscillator.frequency.setValueAtTime(220, audioCtx.currentTime);
            }
            
            oscillator.start();
            gainNode.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + 0.3);
            oscillator.stop(audioCtx.currentTime + 0.3);
        }
    };

    // --- Transmitter Logic ---
    const Transmitter = {
        async start() {
            if (!appState.fileBuffer) {
                alert('Please select a file first.');
                return;
            }
            appState.isTransmitting = true;
            document.getElementById('startTransmissionBtn').disabled = true;
            document.getElementById('send-progress').style.display = 'block';
            UI.setStatus('sendStatus', 'Packetizing data...');

            this.buildPackets();
            UI.playSound('start');

            const flashScreen = document.getElementById('flashScreen');
            flashScreen.innerHTML = ''; // Clear previous grid
            flashScreen.classList.add('active');

            appState.startTime = Date.now();
            await this.transmitPreamble();
            
            for (let i = 0; i < appState.packets.length; i++) {
                if (!appState.isTransmitting) break;
                const packet = appState.packets[i];
                const percentage = ((i + 1) / appState.packets.length) * 100;
                UI.setStatus('sendStatus', `Transmitting packet ${i+1}/${appState.packets.length}`);
                UI.updateProgress('send-progress-bar', percentage);
                
                const elapsed = Date.now() - appState.startTime;
                const speed = i / (elapsed / 1000); // packets/sec
                const remainingPackets = appState.packets.length - i;
                const remainingTime = speed > 0 ? (remainingPackets / speed).toFixed(1) : '...';
                document.getElementById('sendTime').textContent = `${remainingTime}s`;

                await this.transmitPacket(packet);
            }

            this.stop();
        },
        stop() {
            if (!appState.isTransmitting) return;
            appState.isTransmitting = false;
            UI.setStatus('sendStatus', 'Finished!');
            UI.playSound('end');
            setTimeout(() => {
                document.getElementById('flashScreen').classList.remove('active');
                document.getElementById('startTransmissionBtn').disabled = false;
                document.getElementById('send-progress').style.display = 'none';
                UI.updateProgress('send-progress-bar', 0);
            }, 1000);
        },
        buildPackets() {
            appState.packets = [];
            
            // 1. Metadata Packet
            const metadata = {
                fileName: appState.file.name,
                fileSize: appState.fileBuffer.length,
                protocol: appState.protocol,
                packetSize: PACKET_SIZE,
                totalPackets: Math.ceil(appState.fileBuffer.length / PACKET_SIZE)
            };
            appState.totalPackets = metadata.totalPackets;
            const metadataStr = JSON.stringify(metadata);
            const metadataBytes = new TextEncoder().encode(metadataStr);
            appState.packets.push(this.createPacket(PACKET_TYPE.METADATA, 0, metadataBytes));

            // 2. Data Packets
            for (let i = 0; i < appState.totalPackets; i++) {
                const start = i * PACKET_SIZE;
                const end = start + PACKET_SIZE;
                const chunk = appState.fileBuffer.slice(start, end);
                appState.packets.push(this.createPacket(PACKET_TYPE.DATA, i + 1, chunk));
            }
            
            // 3. End of Transmission Packet
            appState.packets.push(this.createPacket(PACKET_TYPE.EOT, appState.totalPackets + 1, new Uint8Array()));
        },
        createPacket(type, index, payload) {
            // Header: [Type (1), Index (4)] = 5 bytes
            const header = new ArrayBuffer(5);
            const headerView = new DataView(header);
            headerView.setUint8(0, type);
            headerView.setUint32(1, index, false); // Big-endian
            
            const packetData = new Uint8Array(5 + payload.length);
            packetData.set(new Uint8Array(header), 0);
            packetData.set(payload, 5);

            // Checksum: 4 bytes
            const checksum = crc32(packetData);
            const checksumBytes = new ArrayBuffer(4);
            new DataView(checksumBytes).setUint32(0, checksum, false);
            
            // Final Packet: [Data (N) + Checksum (4)]
            const finalPacket = new Uint8Array(packetData.length + 4);
            finalPacket.set(packetData, 0);
            finalPacket.set(new Uint8Array(checksumBytes), packetData.length);
            
            return finalPacket;
        },
        async transmitPreamble() {
            const symbolRate = parseInt(document.getElementById('symbolRate').value);
            UI.setStatus('sendStatus', 'Sending Preamble...');
            document.getElementById('flashInfo').textContent = "SYNC";
            for (const color of PREAMBLE) {
                await this.flash(color, symbolRate);
            }
        },
        async transmitPacket(packet) {
            const bits = [];
            packet.forEach(byte => {
                for (let i = 7; i >= 0; i--) {
                    bits.push((byte >> i) & 1);
                }
            });

            const protocol = PROTOCOLS[appState.protocol];
            const symbolRate = parseInt(document.getElementById('symbolRate').value);
            
            for (let i = 0; i < bits.length; i += protocol.bitsPerSymbol) {
                if (!appState.isTransmitting) return;

                const chunk = bits.slice(i, i + protocol.bitsPerSymbol);
                while(chunk.length < protocol.bitsPerSymbol) chunk.push(0); // Pad last chunk
                
                if (protocol.isSpatial) {
                    await this.flashSpatial(chunk, symbolRate);
                } else {
                    const value = parseInt(chunk.join(''), 2);
                    const color = protocol.colors[value];
                    await this.flash(color, symbolRate);
                }
            }
        },
        flash(color, duration) {
            return new Promise(resolve => {
                document.getElementById('flashScreen').style.backgroundColor = color;
                setTimeout(resolve, duration);
            });
        },
        flashSpatial(bits, duration) {
            return new Promise(resolve => {
                const flashScreen = document.getElementById('flashScreen');
                const turboColors = PROTOCOLS.TURBO.colors;

                let gridHTML = '<div class="flash-grid">';
                // bits are [q1_b1, q1_b2, q2_b1, q2_b2, ...]
                for (let i = 0; i < 4; i++) {
                    const val = (bits[i*2] << 1) | (bits[i*2 + 1] || 0);
                    gridHTML += `<div class="flash-quadrant" style="background: ${turboColors[val]}"></div>`;
                }
                gridHTML += '</div>';
                flashScreen.innerHTML = gridHTML;

                setTimeout(resolve, duration);
            });
        }
    };

    // --- Receiver Logic ---
    const Receiver = {
        animationFrameId: null,
        stream: null,
        async start() {
            if (this.stream) this.stop();
            try {
                const video = document.getElementById('cameraView');
                this.stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'environment', width: { ideal: 640 }, height: { ideal: 480 } }
                });
                video.srcObject = this.stream;
                await video.play();
                
                appState.isReceiving = true;
                document.getElementById('startReceiverBtn').textContent = '⏹️ Stop Camera';
                document.getElementById('startReceiverBtn').onclick = () => Receiver.stop();
                document.getElementById('calibrateBtn').disabled = false;
                UI.setStatus('receiveStatus', 'Camera Started. Please Calibrate.');
                this.loop();
            } catch (err) {
                UI.log('Error starting camera: ' + err.message, 'error');
            }
        },
        stop() {
            if (this.animationFrameId) cancelAnimationFrame(this.animationFrameId);
            if (this.stream) this.stream.getTracks().forEach(track => track.stop());
            this.stream = null;
            appState.isReceiving = false;
            appState.isCalibrating = false;
            
            document.getElementById('startReceiverBtn').textContent = '📹 Start Camera';
            document.getElementById('startReceiverBtn').onclick = () => Receiver.start();
            document.getElementById('calibrateBtn').disabled = true;
            UI.setStatus('receiveStatus', 'Idle');
        },
        loop() {
            const video = document.getElementById('cameraView');
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            
            const processFrame = () => {
                if (!appState.isReceiving || video.paused || video.ended) return;
                
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                
                // For simplicity, we sample a single central point
                // A real app might average a larger area
                const sample = ctx.getImageData(canvas.width / 2, canvas.height / 2, 1, 1).data;
                const color = { r: sample[0], g: sample[1], b: sample[2] };
                
                document.getElementById('reticle').style.borderColor = `rgb(${color.r}, ${color.g}, ${color.b})`;

                if (appState.isCalibrating) {
                    this.calibrationStep(color);
                } else {
                    this.decodeStep(color);
                }
                
                this.animationFrameId = requestAnimationFrame(processFrame);
            };
            this.animationFrameId = requestAnimationFrame(processFrame);
        },
        startCalibration() {
            if (!appState.isReceiving) return;
            UI.log('Starting calibration... Follow sender prompts.', 'info');
            UI.setStatus('receiveStatus', 'Calibrating...');
            document.getElementById('calibrateBtn').disabled = true;
            
            appState.isCalibrating = true;
            appState.calibratedColors = {};
            this.calibrationState = {
                step: 0,
                colorToCalibrate: null,
                readings: [],
                lastColor: null
            };

            const senderProtocolId = prompt("Enter the SENDER's protocol (STANDARD, TURBO, HYPER):", "TURBO").toUpperCase();
            if (!PROTOCOLS[senderProtocolId]) {
                alert("Invalid protocol!");
                this.stopCalibration();
                return;
            }
            this.calibrationState.protocol = PROTOCOLS[senderProtocolId];
            this.calibrationState.colorToCalibrate = this.calibrationState.protocol.colors[0];
            
            UI.log(`Please ask sender to flash: ${this.calibrationState.colorToCalibrate}`, 'info');
            Transmitter.flash(this.calibrationState.colorToCalibrate, 10000); // Flash color for 10s
        },
        stopCalibration() {
            appState.isCalibrating = false;
            document.getElementById('calibrateBtn').disabled = false;
            document.getElementById('flashScreen').classList.remove('active');
            UI.setStatus('receiveStatus', 'Calibration complete. Ready to receive.');
        },
        calibrationStep(color) {
            const state = this.calibrationState;
            state.readings.push(color);
            
            if (state.readings.length > 50) { // Take 50 readings
                let avg = {r:0, g:0, b:0};
                state.readings.forEach(c => { avg.r += c.r; avg.g += c.g; avg.b += c.b; });
                avg.r /= state.readings.length;
                avg.g /= state.readings.length;
                avg.b /= state.readings.length;
                
                appState.calibratedColors[state.colorToCalibrate] = avg;
                UI.log(`Calibrated ${state.colorToCalibrate} to RGB(${avg.r.toFixed(0)}, ${avg.g.toFixed(0)}, ${avg.b.toFixed(0)})`, 'success');

                state.step++;
                state.readings = [];
                
                if (state.step >= state.protocol.colors.length) {
                    UI.log('Calibration finished!', 'success');
                    this.stopCalibration();
                    return;
                }
                
                state.colorToCalibrate = state.protocol.colors[state.step];
                UI.log(`Please ask sender to flash: ${state.colorToCalibrate}`, 'info');
                Transmitter.flash(state.colorToCalibrate, 10000);
            }
        },
        decodeStep(color) {
            // This is a simplified decoder. A real one would be much more complex,
            // with state machines for sync, packet parsing, etc.
            // For now, it just demonstrates finding the closest color.
            if (Object.keys(appState.calibratedColors).length === 0) return;

            const closest = this.findClosestColor(color);
            // This is where the actual bitstream processing and packet reconstruction would go.
            // Due to complexity, this part is left as a placeholder.
            // UI.log(`Detected: ${closest.color}`, 'info'); 
        },
        findClosestColor(rgb) {
            let minDistance = Infinity;
            let closestColor = null;
            let closestIndex = -1;
            
            const calibratedEntries = Object.entries(appState.calibratedColors);

            for(let i=0; i < calibratedEntries.length; i++) {
                const [hex, calRgb] = calibratedEntries[i];
                const distance = Math.sqrt(
                    Math.pow(rgb.r - calRgb.r, 2) +
                    Math.pow(rgb.g - calRgb.g, 2) +
                    Math.pow(rgb.b - calRgb.b, 2)
                );
                if (distance < minDistance) {
                    minDistance = distance;
                    closestColor = hex;
                    closestIndex = i;
                }
            }
            return { color: closestColor, index: closestIndex };
        },
        // --- Full-fledged decoding logic would go here ---
        // This includes:
        // 1. Detecting preamble sync
        // 2. Reading bits based on symbol timing
        // 3. Assembling bits into packets
        // 4. Validating checksum
        // 5. Storing valid packets
        // 6. Reconstructing file when EOT packet is received.
        // This is a significant undertaking beyond this example's scope.
        // For now, we'll simulate receiving a file.
        simulateFileReception() {
            if (!appState.fileBuffer) { UI.log("No file selected on sender to simulate.", "error"); return; }
            UI.setStatus("receiveStatus", "Receiving...");
            appState.receivedPackets = {};
            appState.totalPackets = Math.ceil(appState.fileBuffer.length / PACKET_SIZE);
            let receivedCount = 0;
            const interval = setInterval(() => {
                receivedCount++;
                const percentage = (receivedCount / appState.totalPackets) * 100;
                UI.updateProgress('receive-progress-bar', percentage);
                document.getElementById('downloaded').textContent = `${(receivedCount * PACKET_SIZE / 1024).toFixed(1)} KB`;
                if(receivedCount >= appState.totalPackets) {
                    clearInterval(interval);
                    this.reconstructFile();
                }
            }, 50);
        },
        reconstructFile() {
            UI.setStatus("receiveStatus", "File Received! Reconstructing...");
            const blob = new Blob([appState.fileBuffer], { type: appState.file.type });
            const url = URL.createObjectURL(blob);
            const a = document.getElementById('downloadLink');
            a.href = url;
            a.download = appState.file.name;
            a.textContent = `Download "${appState.file.name}"`;
            a.style.display = 'block';
            UI.log("File reconstructed and ready for download.", "success");
            UI.playSound('end');
        }

    };

    // --- Initialize App ---
    window.onload = () => {
        UI.init();
    };

    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PhotonLink - Advanced Color Data Transfer</title>
    <style>
        :root {
            --bg-color: #f0f2f5;
            --surface-color: #ffffff;
            --text-color: #1c1e21;
            --text-secondary-color: #606770;
            --primary-color-start: #4c68d7;
            --primary-color-end: #6a3a9f;
            --primary-text-color: #ffffff;
            --border-color: #ccd0d5;
            --shadow-color: rgba(0, 0, 0, 0.1);
            --danger-color: #fa383e;
            --warning-bg: #fffbe6;
            --warning-border: #ffe58f;
            --warning-text: #ad8b00;
            --success-color: #31a24c;
        }

        .dark-mode {
            --bg-color: #18191a;
            --surface-color: #242526;
            --text-color: #e4e6eb;
            --text-secondary-color: #b0b3b8;
            --border-color: #3e4042;
            --shadow-color: rgba(0, 0, 0, 0.3);
            --warning-bg: #4d4420;
            --warning-border: #6e612f;
            --warning-text: #ffe58f;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background: var(--bg-color);
            color: var(--text-color);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            transition: background-color 0.3s, color 0.3s;
        }
        .container {
            background: var(--surface-color);
            border-radius: 24px;
            box-shadow: 0 12px 28px 0 var(--shadow-color), 0 2px 4px 0 var(--shadow-color);
            max-width: 960px;
            width: 100%;
            overflow: hidden;
            animation: fadeIn 0.5s ease-out;
        }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
        
        .header {
            background: linear-gradient(135deg, var(--primary-color-start), var(--primary-color-end));
            padding: 30px;
            text-align: center;
            color: var(--primary-text-color);
            position: relative;
        }
        .header h1 { font-size: 32px; margin-bottom: 8px; }
        .theme-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            width: 40px; height: 40px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 20px;
            display: flex; justify-content: center; align-items: center;
            transition: background 0.2s;
        }
        .theme-toggle:hover { background: rgba(255,255,255,0.3); }

        .mode-selector { display: flex; background: var(--bg-color); padding: 8px; }
        .mode-btn {
            flex: 1; padding: 16px; background: transparent; border: none; border-radius: 12px;
            font-size: 16px; font-weight: 600; cursor: pointer; transition: all 0.3s ease;
            color: var(--text-secondary-color);
        }
        .mode-btn.active {
            background: var(--surface-color);
            color: var(--text-color);
            box-shadow: 0 2px 8px var(--shadow-color);
        }
        .content { padding: 30px; }
        .section { display: none; }
        .section.active { display: block; animation: contentFadeIn 0.4s; }
        @keyframes contentFadeIn { from { opacity: 0; } to { opacity: 1; } }

        fieldset {
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 24px;
        }
        legend {
            font-weight: 600;
            padding: 0 10px;
            color: var(--text-color);
        }
        .input-group { margin-bottom: 20px; }
        label { display: block; margin-bottom: 8px; font-weight: 500; font-size: 14px; }
        textarea, input, select {
            width: 100%; padding: 12px; border: 1px solid var(--border-color);
            border-radius: 8px; font-size: 14px; background: var(--bg-color);
            color: var(--text-color); transition: border-color 0.2s;
        }
        textarea:focus, input:focus, select:focus {
            outline: none; border-color: var(--primary-color-start);
        }
        textarea { min-height: 120px; resize: vertical; }

        .button-group { display: flex; gap: 10px; }
        .button-group button { flex: 1; }
        .btn {
            padding: 14px 28px; border: none; border-radius: 8px;
            font-size: 16px; font-weight: 600; cursor: pointer;
            transition: all 0.2s ease;
        }
        .btn-primary {
            background: linear-gradient(135deg, var(--primary-color-start), var(--primary-color-end));
            color: var(--primary-text-color);
        }
        .btn-primary:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.2); }
        .btn-danger { background: var(--danger-color); color: white; }
        .btn-danger:hover { background: #d32f34; }
        
        .info-box {
            background: var(--warning-bg); border: 1px solid var(--warning-border);
            border-radius: 8px; padding: 16px; margin-bottom: 20px;
            color: var(--warning-text); font-size: 14px;
        }

        .stats {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 16px; margin-top: 24px;
        }
        .stat-item {
            text-align: center; padding: 16px; background: var(--bg-color);
            border-radius: 12px;
        }
        .stat-label { font-size: 12px; color: var(--text-secondary-color); font-weight: 600; text-transform: uppercase; margin-bottom: 8px; }
        .stat-value { font-size: 22px; font-weight: bold; color: var(--text-color); }

        progress {
            width: 100%;
            height: 10px;
            border-radius: 5px;
            overflow: hidden;
            border: 1px solid var(--border-color);
        }
        progress::-webkit-progress-bar { background-color: var(--bg-color); }
        progress::-webkit-progress-value {
            background: linear-gradient(135deg, var(--primary-color-start), var(--primary-color-end));
            transition: width 0.1s linear;
        }

        #flashScreen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 9999; display: none; flex-direction: column;
            justify-content: center; align-items: center;
        }
        #flashScreen.ludicrous { display: grid; grid-template-columns: 1fr 1fr; grid-template-rows: 1fr 1fr; }
        .flash-lane { width: 100%; height: 100%; }

        #receive-container { position: relative; }
        #cameraView { max-width: 100%; border-radius: 12px; background: #000; display: none; }
        #cameraOverlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        #logArea {
            margin-top: 20px; background: var(--bg-color); border-radius: 8px;
            padding: 15px; height: 150px; overflow-y: auto; font-family: monospace;
            font-size: 12px; line-height: 1.6; color: var(--text-secondary-color);
        }
        #logArea p { margin: 0; padding: 2px 0; }
        #logArea .log-success { color: var(--success-color); }
        #logArea .log-error { color: var(--danger-color); }

        .tooltip { position: relative; display: inline-block; cursor: help; }
        .tooltip .tooltiptext {
            visibility: hidden; width: 220px; background-color: #333; color: #fff;
            text-align: center; border-radius: 6px; padding: 8px;
            position: absolute; z-index: 1; bottom: 125%; left: 50%;
            margin-left: -110px; opacity: 0; transition: opacity 0.3s; font-size: 12px; font-weight: normal;
        }
        .tooltip:hover .tooltiptext { visibility: visible; opacity: 1; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <button id="themeToggle" class="theme-toggle">üåô</button>
            <h1>PhotonLink</h1>
            <p>Advanced Data Transfer via Modulated Light</p>
        </div>

        <div class="mode-selector">
            <button class="mode-btn active" onclick="switchMode('send')">üì§ Send</button>
            <button class="mode-btn" onclick="switchMode('receive')">üì• Receive</button>
        </div>

        <div class="content">
            <div id="sendMode" class="section active">
                <fieldset>
                    <legend>1. Select Data</legend>
                    <div class="input-group">
                        <label for="dataType">Data Type:</label>
                        <select id="dataType" onchange="switchDataType(this.value)">
                            <option value="text">üìù Text</option>
                            <option value="file">üì¶ File</option>
                        </select>
                    </div>
                    <div id="textInput" class="input-group">
                        <textarea id="inputText" placeholder="Type your message here..."></textarea>
                    </div>
                    <div id="fileInput" class="input-group" style="display: none;">
                        <input type="file" id="inputFile">
                        <p id="fileInfo" style="font-size: 12px; margin-top: 8px; color: var(--text-secondary-color);"></p>
                    </div>
                </fieldset>

                <fieldset>
                    <legend>2. Configure Transmission</legend>
                    <div class="input-group">
                        <label for="transferMode">
                            Transfer Mode
                            <span class="tooltip">
                                ‚ìò
                                <span class="tooltiptext">
                                    <b>Standard (2 Colors):</b> 1 bit/flash. Slowest, most reliable.<br>
                                    <b>Turbo (4 Colors):</b> 2 bits/flash. 2x speed.<br>
                                    <b>Hyper (8 Colors):</b> 3 bits/flash. 3x speed, needs good lighting.<br>
                                    <b>Ludicrous (4x2 Colors):</b> 4 parallel lanes. 4x speed, for advanced users.
                                </span>
                            </span>
                        </label>
                        <select id="transferMode">
                            <option value="standard">Standard (Slow & Reliable)</option>
                            <option value="turbo" selected>Turbo (Fast)</option>
                            <option value="hyper">Hyper (Very Fast)</option>
                            <option value="ludicrous">Ludicrous (Experimental)</option>
                        </select>
                    </div>
                    <div class="input-group">
                        <label for="bitSpeed">Symbol Speed (ms per flash)</label>
                        <input type="number" id="bitSpeed" value="80" min="20" max="500" step="10">
                    </div>
                    <div class="input-group">
                        <label for="errorCorrection">
                            Error Correction
                            <span class="tooltip">
                                ‚ìò
                                <span class="tooltiptext">Adds redundant data to automatically fix errors caused by flicker or mis-read colors. Increases transmission time but drastically improves success rate.</span>
                            </span>
                        </label>
                        <select id="errorCorrection">
                            <option value="none">None (Fastest)</option>
                            <option value="crc32">CRC32 Checksum (Error Detection)</option>
                            <option value="repetition" selected>Repetition Code (Error Correction)</option>
                        </select>
                    </div>
                </fieldset>
                
                <button class="btn btn-primary" onclick="startTransmission()">üöÄ Start Transmission</button>
                
                <div id="sendStats" class="stats" style="display: none;">
                    <div class="stat-item"><div class="stat-label">Total Size</div><div class="stat-value" id="dataSize">0 B</div></div>
                    <div class="stat-item"><div class="stat-label">Est. Time</div><div class="stat-value" id="timeRemaining">--</div></div>
                    <div class="stat-item"><div class="stat-label">Mode</div><div class="stat-value" id="modeIndicator">--</div></div>
                    <div class="stat-item"><div class="stat-label">Status</div><div class="stat-value" id="sendStatus">Idle</div></div>
                    <div style="grid-column: 1 / -1;">
                        <progress id="progressBar" value="0" max="100"></progress>
                    </div>
                </div>
            </div>

            <div id="receiveMode" class="section">
                <div class="info-box">
                    <strong>üì± Setup Instructions:</strong><br>
                    1. Ensure sender's screen is visible and stable.<br>
                    2. Match the sender's Transfer Mode and Error Correction settings.<br>
                    3. Click Start, then point your camera at the flashing screen. Keep it steady.
                </div>

                <fieldset>
                    <legend>Receiver Configuration</legend>
                     <div class="input-group">
                        <label for="transferModeReceive">Transfer Mode</label>
                        <select id="transferModeReceive">
                            <option value="standard">Standard</option>
                            <option value="turbo" selected>Turbo</option>
                            <option value="hyper">Hyper</option>
                            <option value="ludicrous">Ludicrous</option>
                        </select>
                    </div>
                    <div class="input-group">
                        <label for="errorCorrectionReceive">Error Correction</label>
                        <select id="errorCorrectionReceive">
                            <option value="none">None</option>
                            <option value="crc32">CRC32 Checksum</option>
                            <option value="repetition" selected>Repetition Code</option>
                        </select>
                    </div>
                </fieldset>

                <div class="button-group">
                    <button class="btn btn-primary" onclick="startReceiving()">üìπ Start Receiving</button>
                    <button class="btn btn-danger" onclick="stopReceiving()">‚èπÔ∏è Stop</button>
                </div>

                <div id="receive-container" style="margin-top: 20px;">
                    <video id="cameraView" autoplay playsinline></video>
                    <canvas id="cameraOverlay"></canvas>
                </div>
                
                <div id="logArea">
                    <p>Receiver log will appear here...</p>
                </div>

                 <div id="downloadArea" style="margin-top:20px; text-align:center;"></div>

            </div>
        </div>
    </div>

    <div id="flashScreen">
        </div>

    <script>
    // --- CRC32 Implementation ---
    // A simple, standard CRC32 implementation.
    const crc32 = (function() {
        const table = new Uint32Array(256);
        for(let i=0; i<256; ++i) {
            let c = i;
            for(let j=0; j<8; ++j) {
                c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
            }
            table[i] = c;
        }
        return function(bytes) {
            let crc = -1;
            for(let i=0; i<bytes.length; ++i) {
                crc = (crc >>> 8) ^ table[(crc ^ bytes[i]) & 0xFF];
            }
            return (crc ^ -1) >>> 0;
        };
    })();

    // --- State & Constants ---
    let appState = {
        currentView: 'send',
        transmission: { active: false, intervalId: null },
        receiver: { active: false, animationFrameId: null }
    };

    const ENCODING_SCHEMES = {
        standard: { bits: 1, colors: ['#ff0000', '#0000ff'] }, // Red=0, Blue=1
        turbo:    { bits: 2, colors: ['#ff0000', '#00ff00', '#0000ff', '#ffff00'] }, // R=00, G=01, B=10, Y=11
        hyper:    { bits: 3, colors: ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff', '#ffffff', '#666666'] }, // R,G,B,Y,M,C,W,Gray
        ludicrous: { bits: 2, colors: ['#ff0000', '#00ff00', '#0000ff', '#ffff00'], lanes: 4 }
    };
    
    // --- UI Management ---
    const ui = {
        // Sender elements
        dataType: document.getElementById('dataType'),
        textInput: document.getElementById('textInput'),
        fileInput: document.getElementById('fileInput'),
        inputFile: document.getElementById('inputFile'),
        fileInfo: document.getElementById('fileInfo'),
        transferMode: document.getElementById('transferMode'),
        bitSpeed: document.getElementById('bitSpeed'),
        errorCorrection: document.getElementById('errorCorrection'),
        sendStats: document.getElementById('sendStats'),
        dataSize: document.getElementById('dataSize'),
        timeRemaining: document.getElementById('timeRemaining'),
        modeIndicator: document.getElementById('modeIndicator'),
        sendStatus: document.getElementById('sendStatus'),
        progressBar: document.getElementById('progressBar'),
        flashScreen: document.getElementById('flashScreen'),
        // Receiver elements
        transferModeReceive: document.getElementById('transferModeReceive'),
        errorCorrectionReceive: document.getElementById('errorCorrectionReceive'),
        cameraView: document.getElementById('cameraView'),
        cameraOverlay: document.getElementById('cameraOverlay'),
        logArea: document.getElementById('logArea'),
        downloadArea: document.getElementById('downloadArea'),
        themeToggle: document.getElementById('themeToggle')
    };

    function switchMode(mode) {
        appState.currentView = mode;
        document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.toggle('active', btn.textContent.toLowerCase().includes(mode)));
        document.getElementById('sendMode').classList.toggle('active', mode === 'send');
        document.getElementById('receiveMode').classList.toggle('active', mode === 'receive');
        if (mode === 'send' && appState.receiver.active) stopReceiving();
        if (mode === 'receive' && appState.transmission.active) stopTransmission();
    }

    function switchDataType(type) {
        ui.textInput.style.display = type === 'text' ? 'block' : 'none';
        ui.fileInput.style.display = type === 'file' ? 'block' : 'none';
    }

    ui.inputFile.onchange = () => {
        if (ui.inputFile.files.length > 0) {
            const file = ui.inputFile.files[0];
            ui.fileInfo.textContent = `Selected: ${file.name} (${formatBytes(file.size)})`;
        } else {
            ui.fileInfo.textContent = '';
        }
    };

    ui.themeToggle.onclick = () => {
        document.body.classList.toggle('dark-mode');
        ui.themeToggle.textContent = document.body.classList.contains('dark-mode') ? '‚òÄÔ∏è' : 'üåô';
    };

    function log(message, type = 'info') {
        const p = document.createElement('p');
        p.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
        if (type === 'success') p.classList.add('log-success');
        if (type === 'error') p.classList.add('log-error');
        ui.logArea.appendChild(p);
        ui.logArea.scrollTop = ui.logArea.scrollHeight;
    }

    // --- Data Handling & Packetization ---
    const SYNC_PATTERN = [0,1,2,3]; // A unique start sequence
    const PACKET_HEADER_SIZE = 8; // bytes: 4 for payload size, 4 for checksum

    function createPacket(dataBytes, errorCorrection) {
        let payload = new Uint8Array(dataBytes);
        
        // Apply error correction to payload
        if (errorCorrection === 'repetition') {
            const repeatedPayload = new Uint8Array(payload.length * 3);
            for(let i=0; i<payload.length; i++) {
                repeatedPayload[i*3] = payload[i];
                repeatedPayload[i*3 + 1] = payload[i];
                repeatedPayload[i*3 + 2] = payload[i];
            }
            payload = repeatedPayload;
        }

        const checksum = (errorCorrection === 'crc32') ? crc32(payload) : 0;
        
        const header = new ArrayBuffer(PACKET_HEADER_SIZE);
        const headerView = new DataView(header);
        headerView.setUint32(0, payload.length, false); // Big-endian
        headerView.setUint32(4, checksum, false);

        const packet = new Uint8Array(SYNC_PATTERN.length + PACKET_HEADER_SIZE + payload.length);
        packet.set(new Uint8Array(SYNC_PATTERN), 0);
        packet.set(new Uint8Array(header), SYNC_PATTERN.length);
        packet.set(payload, SYNC_PATTERN.length + PACKET_HEADER_SIZE);
        
        return packet;
    }

    async function prepareData() {
        const dataType = ui.dataType.value;
        if (dataType === 'text') {
            const text = document.getElementById('inputText').value;
            if (!text) { alert('Please enter text to send.'); return null; }
            return new TextEncoder().encode(text);
        } else {
            const file = ui.inputFile.files[0];
            if (!file) { alert('Please select a file to send.'); return null; }
            const arrayBuffer = await file.arrayBuffer();
            // Prepend filename for the receiver
            const fileNameBytes = new TextEncoder().encode(file.name);
            const data = new Uint8Array(1 + fileNameBytes.length + arrayBuffer.byteLength);
            data[0] = fileNameBytes.length;
            data.set(fileNameBytes, 1);
            data.set(new Uint8Array(arrayBuffer), 1 + fileNameBytes.length);
            return data;
        }
    }
    
    // --- Transmission Logic ---
    async function startTransmission() {
        if (appState.transmission.active) return;

        const dataBytes = await prepareData();
        if (!dataBytes) return;

        const mode = ui.transferMode.value;
        const speed = parseInt(ui.bitSpeed.value);
        const ec = ui.errorCorrection.value;
        const scheme = ENCODING_SCHEMES[mode];
        
        const packet = createPacket(dataBytes, ec);
        const bitStream = bytesToBits(packet, scheme.bits);

        const estimatedTime = (bitStream.length * speed) / 1000;
        
        ui.sendStats.style.display = 'grid';
        ui.dataSize.textContent = formatBytes(packet.length);
        ui.timeRemaining.textContent = `${Math.ceil(estimatedTime)}s`;
        ui.modeIndicator.textContent = mode.charAt(0).toUpperCase() + mode.slice(1);
        ui.sendStatus.textContent = 'Transmitting...';
        ui.progressBar.value = 0;

        appState.transmission.active = true;
        let currentIndex = 0;
        let isWhite = false;

        ui.flashScreen.innerHTML = '';
        if(mode === 'ludicrous') {
            ui.flashScreen.classList.add('ludicrous');
            for(let i=0; i<scheme.lanes; i++) {
                const lane = document.createElement('div');
                lane.classList.add('flash-lane');
                lane.id = `flash-lane-${i}`;
                ui.flashScreen.appendChild(lane);
            }
        } else {
            ui.flashScreen.classList.remove('ludicrous');
        }
        ui.flashScreen.style.display = mode === 'ludicrous' ? 'grid' : 'flex';

        appState.transmission.intervalId = setInterval(() => {
            if (!appState.transmission.active || currentIndex >= bitStream.length) {
                stopTransmission();
                ui.sendStatus.textContent = '‚úÖ Complete';
                return;
            }

            if (isWhite) {
                if(mode === 'ludicrous') {
                    for(let i=0; i<scheme.lanes; i++) document.getElementById(`flash-lane-${i}`).style.backgroundColor = '#000';
                } else {
                    ui.flashScreen.style.backgroundColor = '#000'; // Use black as separator
                }
            } else {
                if(mode === 'ludicrous') {
                    for (let i = 0; i < scheme.lanes; i++) {
                        if (currentIndex + i < bitStream.length) {
                            const symbol = bitStream[currentIndex + i];
                            document.getElementById(`flash-lane-${i}`).style.backgroundColor = scheme.colors[symbol];
                        }
                    }
                } else {
                    const symbol = bitStream[currentIndex];
                    ui.flashScreen.style.backgroundColor = scheme.colors[symbol];
                }
            }
            
            if (!isWhite) {
                 currentIndex += (mode === 'ludicrous' ? scheme.lanes : 1);
                 ui.progressBar.value = (currentIndex / bitStream.length) * 100;
            }
            isWhite = !isWhite;
        }, speed / 2);
    }

    function stopTransmission() {
        if (!appState.transmission.active) return;
        clearInterval(appState.transmission.intervalId);
        appState.transmission.active = false;
        ui.flashScreen.style.display = 'none';
        ui.sendStatus.textContent = 'Stopped';
    }

    // --- Receiver Logic ---
    let receiverState = {};

    function resetReceiverState() {
        receiverState = {
            status: 'IDLE', // IDLE, SYNCING, READING_HEADER, READING_PAYLOAD, VERIFYING
            buffer: [],
            header: null,
            payloadSize: 0,
            payload: [],
            lastSymbolTime: 0,
            lastSymbol: -1,
            detectedSpeed: 100,
        };
        ui.downloadArea.innerHTML = '';
        ui.logArea.innerHTML = '';
    }

    async function startReceiving() {
        if (appState.receiver.active) return;
        
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });
            ui.cameraView.srcObject = stream;
            ui.cameraView.style.display = 'block';
            await ui.cameraView.play();
            appState.receiver.active = true;
            resetReceiverState();
            log('Camera started. Point at the sender.', 'info');
            log(`Mode: ${ui.transferModeReceive.value}, EC: ${ui.errorCorrectionReceive.value}`, 'info');
            receiverState.status = 'SYNCING';
            appState.receiver.animationFrameId = requestAnimationFrame(captureFrame);
        } catch (err) {
            log(`Camera error: ${err.message}`, 'error');
            alert('Could not access the camera. Please grant permission.');
        }
    }

    function stopReceiving() {
        if (!appState.receiver.active) return;
        cancelAnimationFrame(appState.receiver.animationFrameId);
        appState.receiver.active = false;
        if (ui.cameraView.srcObject) {
            ui.cameraView.srcObject.getTracks().forEach(track => track.stop());
        }
        ui.cameraView.style.display = 'none';
        log('Receiver stopped.', 'info');
    }
    
    function captureFrame() {
        if (!appState.receiver.active) return;
        
        const mode = ui.transferModeReceive.value;
        const scheme = ENCODING_SCHEMES[mode];
        const ctx = ui.cameraOverlay.getContext('2d');
        const w = ui.cameraView.videoWidth;
        const h = ui.cameraView.videoHeight;
        ui.cameraOverlay.width = w;
        ui.cameraOverlay.height = h;

        ctx.drawImage(ui.cameraView, 0, 0, w, h);

        const samplePoints = getSamplePoints(w,h,mode);
        const detectedSymbols = [];
        
        for(let i=0; i<samplePoints.length; i++) {
            const {x, y} = samplePoints[i];
            const size = 20; // Sample area size
            const imageData = ctx.getImageData(x-size/2, y-size/2, size, size).data;
            const avgColor = getAverageColor(imageData);
            
            // Draw sample box for visualization
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 2;
            ctx.strokeRect(x - size / 2, y - size / 2, size, size);

            // Ignore separator color (black)
            if (avgColor.r < 50 && avgColor.g < 50 && avgColor.b < 50) {
                detectedSymbols.push(null);
                continue;
            }

            const symbol = findClosestColor(avgColor, scheme.colors);
            detectedSymbols.push(symbol);
        }
        
        // --- State Machine Logic ---
        const now = performance.now();
        const timeSinceLast = now - receiverState.lastSymbolTime;
        
        // For single-lane modes, process if symbol is new
        if(mode !== 'ludicrous') {
            const symbol = detectedSymbols[0];
            if (symbol !== null && symbol !== receiverState.lastSymbol && timeSinceLast > receiverState.detectedSpeed * 0.4) {
                processSymbol(symbol);
                receiverState.lastSymbolTime = now;
                receiverState.lastSymbol = symbol;
                 if(timeSinceLast < 1000) receiverState.detectedSpeed = (receiverState.detectedSpeed * 0.9) + (timeSinceLast * 0.1);
            }
        }
        // For ludicrous mode, process all symbols if they are not the same as last frame's
        else {
             if (detectedSymbols.some(s => s !== null) && timeSinceLast > receiverState.detectedSpeed * 0.4) {
                 if (JSON.stringify(detectedSymbols) !== JSON.stringify(receiverState.lastSymbol)) {
                    detectedSymbols.forEach(processSymbol);
                    receiverState.lastSymbolTime = now;
                    receiverState.lastSymbol = detectedSymbols;
                    if(timeSinceLast < 1000) receiverState.detectedSpeed = (receiverState.detectedSpeed * 0.9) + (timeSinceLast * 0.1);
                }
             }
        }

        appState.receiver.animationFrameId = requestAnimationFrame(captureFrame);
    }

    function processSymbol(symbol) {
        if(symbol === null) return;

        const scheme = ENCODING_SCHEMES[ui.transferModeReceive.value];
        const bits = symbolToBits(symbol, scheme.bits);

        switch(receiverState.status) {
            case 'SYNCING':
                receiverState.buffer.push(...bits);
                // Check if buffer ends with sync pattern
                const syncBits = bytesToBits(new Uint8Array(SYNC_PATTERN), 1).flat();
                if(receiverState.buffer.length >= syncBits.length) {
                    const tail = receiverState.buffer.slice(-syncBits.length);
                    if (tail.every((v,i) => v === syncBits[i])) {
                        receiverState.status = 'READING_HEADER';
                        receiverState.buffer = [];
                        log('Sync pattern detected!', 'success');
                    }
                }
                break;
            case 'READING_HEADER':
                receiverState.buffer.push(...bits);
                if(receiverState.buffer.length >= PACKET_HEADER_SIZE * 8) {
                    const headerBytes = bitsToBytes(receiverState.buffer.slice(0, PACKET_HEADER_SIZE * 8));
                    const headerView = new DataView(headerBytes.buffer);
                    receiverState.payloadSize = headerView.getUint32(0, false);
                    receiverState.checksum = headerView.getUint32(4, false);
                    receiverState.status = 'READING_PAYLOAD';
                    receiverState.buffer = [];
                    log(`Header received. Payload size: ${formatBytes(receiverState.payloadSize)}, Checksum: ${receiverState.checksum}`, 'info');
                }
                break;
            case 'READING_PAYLOAD':
                receiverState.buffer.push(...bits);
                const progress = (receiverState.buffer.length / (receiverState.payloadSize * 8)) * 100;
                log(`Receiving payload... ${progress.toFixed(1)}%`, 'info'); // This will log a lot, can be throttled
                if(receiverState.buffer.length >= receiverState.payloadSize * 8) {
                    receiverState.status = 'VERIFYING';
                    const payloadBytes = bitsToBytes(receiverState.buffer);
                    
                    let finalPayload = payloadBytes;
                    const ec = ui.errorCorrectionReceive.value;

                    if (ec === 'repetition') {
                        log('Applying repetition error correction...', 'info');
                        const corrected = new Uint8Array(payloadBytes.length / 3);
                        for(let i=0; i<corrected.length; i++) {
                            const b1 = payloadBytes[i*3], b2 = payloadBytes[i*3+1], b3 = payloadBytes[i*3+2];
                            // Majority vote
                            corrected[i] = (b1 === b2 || b1 === b3) ? b1 : b2;
                        }
                        finalPayload = corrected;
                    }

                    if (ec === 'crc32') {
                        log('Verifying CRC32 checksum...', 'info');
                        const calculatedChecksum = crc32(finalPayload);
                        if(calculatedChecksum === receiverState.checksum) {
                            log('Checksum OK!', 'success');
                            processReceivedData(finalPayload);
                        } else {
                            log(`Checksum mismatch! Expected ${receiverState.checksum}, got ${calculatedChecksum}`, 'error');
                            resetReceiverState();
                        }
                    } else {
                        processReceivedData(finalPayload);
                    }
                }
                break;
        }
    }
    
    function processReceivedData(dataBytes) {
        log('Processing received data...', 'success');
        let dataBlob, fileName;

        // Sniff for file or text
        const firstByte = dataBytes[0];
        const potentialFileName = new TextDecoder().decode(dataBytes.slice(1, 1 + firstByte));
        // A simple heuristic: if filename seems valid and length matches, treat as file.
        if(dataBytes.length > 1 + firstByte && /^[a-zA-Z0-9._-]+$/.test(potentialFileName)) {
             log(`File detected: ${potentialFileName}`, 'info');
             fileName = potentialFileName;
             const fileBytes = dataBytes.slice(1 + firstByte);
             dataBlob = new Blob([fileBytes]);
        } else {
            // Assume text
            const text = new TextDecoder().decode(dataBytes);
            log(`Text received: "${text.substring(0, 50)}..."`, 'info');
            dataBlob = new Blob([dataBytes], { type: 'text/plain' });
            fileName = 'received_text.txt';
        }
        
        const downloadLink = document.createElement('a');
        downloadLink.href = URL.createObjectURL(dataBlob);
        downloadLink.download = fileName;
        downloadLink.textContent = `‚úÖ Download ${fileName} (${formatBytes(dataBlob.size)})`;
        downloadLink.classList.add('btn', 'btn-primary');
        ui.downloadArea.innerHTML = '';
        ui.downloadArea.appendChild(downloadLink);
        
        stopReceiving();
    }


    // --- Helper & Utility Functions ---
    function bytesToBits(bytes, symbolSize) {
        const bits = [];
        for (let i = 0; i < bytes.length; i++) {
            for (let j = 7; j >= 0; j--) {
                bits.push((bytes[i] >> j) & 1);
            }
        }
        // Group bits into symbols
        const symbols = [];
        for(let i=0; i<bits.length; i+= symbolSize) {
            let symbol = 0;
            for(let j=0; j<symbolSize; j++) {
                if(i+j < bits.length) {
                    symbol = (symbol << 1) | bits[i+j];
                }
            }
            symbols.push(symbol);
        }
        return symbols;
    }

    function symbolToBits(symbol, symbolSize) {
        const bits = [];
        for(let i=symbolSize-1; i>=0; i--) {
            bits.push((symbol >> i) & 1);
        }
        return bits;
    }
    
    function bitsToBytes(bits) {
        const bytes = new Uint8Array(Math.ceil(bits.length / 8));
        for (let i = 0; i < bytes.length; i++) {
            let byte = 0;
            for (let j = 0; j < 8; j++) {
                if (i * 8 + j < bits.length) {
                    byte = (byte << 1) | bits[i * 8 + j];
                }
            }
            bytes[i] = byte;
        }
        return bytes;
    }

    function getSamplePoints(width, height, mode) {
        if(mode === 'ludicrous') {
            return [
                {x: width * 0.25, y: height * 0.25}, // top-left
                {x: width * 0.75, y: height * 0.25}, // top-right
                {x: width * 0.25, y: height * 0.75}, // bottom-left
                {x: width * 0.75, y: height * 0.75}, // bottom-right
            ];
        }
        return [{x: width/2, y: height/2}]; // center
    }

    function getAverageColor(data) {
        let r=0, g=0, b=0;
        const count = data.length / 4;
        for(let i=0; i<data.length; i+=4) {
            r += data[i]; g += data[i+1]; b += data[i+2];
        }
        return {r: r/count, g: g/count, b: b/count};
    }
    
    function findClosestColor(rgb, palette) {
        let minDistance = Infinity;
        let bestIndex = -1;
        
        const paletteRgb = palette.map(hex => ({
            r: parseInt(hex.slice(1, 3), 16),
            g: parseInt(hex.slice(3, 5), 16),
            b: parseInt(hex.slice(5, 7), 16)
        }));

        for(let i=0; i<paletteRgb.length; i++) {
            const pr = paletteRgb[i];
            const distance = Math.sqrt(Math.pow(rgb.r - pr.r, 2) + Math.pow(rgb.g - pr.g, 2) + Math.pow(rgb.b - pr.b, 2));
            if(distance < minDistance) {
                minDistance = distance;
                bestIndex = i;
            }
        }
        // Threshold to prevent mis-reads on neutral colors
        return minDistance < 80 ? bestIndex : null;
    }

    function formatBytes(bytes, decimals = 2) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const dm = decimals < 0 ? 0 : decimals;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
    }

    // Initial setup
    switchMode('send');
    document.body.classList.contains('dark-mode') ? ui.themeToggle.textContent = '‚òÄÔ∏è' : ui.themeToggle.textContent = 'üåô';

    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visual Data Transfer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        h1 {
            text-align: center;
            color: #667eea;
            margin-bottom: 30px;
            font-size: 2.5em;
        }

        .mode-selector {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
            justify-content: center;
        }

        .mode-btn {
            padding: 15px 40px;
            border: none;
            border-radius: 10px;
            font-size: 1.1em;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
            background: #e0e0e0;
            color: #333;
        }

        .mode-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            transform: scale(1.05);
        }

        .section {
            display: none;
        }

        .section.active {
            display: block;
        }

        textarea {
            width: 100%;
            padding: 15px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            font-size: 1em;
            resize: vertical;
            min-height: 120px;
            font-family: inherit;
        }

        .file-upload {
            margin: 20px 0;
            padding: 30px;
            border: 3px dashed #667eea;
            border-radius: 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }

        .file-upload:hover {
            background: rgba(102, 126, 234, 0.1);
        }

        .file-upload input {
            display: none;
        }

        .controls {
            display: flex;
            gap: 15px;
            margin: 20px 0;
            align-items: center;
            flex-wrap: wrap;
        }

        .control-group {
            flex: 1;
            min-width: 200px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #555;
        }

        input[type="range"] {
            width: 100%;
        }

        select {
            width: 100%;
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1em;
        }

        .control-btn {
            width: 100%;
            padding: 15px;
            border: none;
            border-radius: 10px;
            font-size: 1.2em;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            margin-top: 10px;
        }

        .control-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
        }

        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #display-canvas {
            width: 100%;
            max-width: 600px;
            height: 600px;
            margin: 20px auto;
            display: block;
            background: white;
            border: 4px solid #333;
            border-radius: 10px;
            image-rendering: pixelated;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .stat-item {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 15px;
            border-radius: 10px;
            color: white;
            text-align: center;
        }

        .stat-label {
            font-size: 0.9em;
            opacity: 0.9;
        }

        .stat-value {
            font-size: 1.5em;
            font-weight: 600;
            margin-top: 5px;
        }

        #video {
            width: 100%;
            max-width: 640px;
            height: auto;
            display: block;
            margin: 20px auto;
            border-radius: 10px;
            border: 4px solid #333;
        }

        .canvas-row {
            display: flex;
            gap: 10px;
            margin: 20px 0;
            justify-content: center;
            flex-wrap: wrap;
        }

        .canvas-container {
            text-align: center;
        }

        .canvas-container canvas {
            border: 2px solid #333;
            background: #000;
        }

        .canvas-container p {
            margin-top: 5px;
            font-size: 0.9em;
            color: #666;
        }

        .info-box {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            border-left: 4px solid #2196f3;
        }

        .preview-container {
            margin: 20px 0;
            padding: 20px;
            background: #f5f5f5;
            border-radius: 10px;
            min-height: 200px;
        }

        .preview-container img {
            max-width: 100%;
            border-radius: 10px;
        }

        .preview-container pre {
            white-space: pre-wrap;
            word-wrap: break-word;
            font-family: 'Courier New', monospace;
        }

        .progress-bar {
            width: 100%;
            height: 30px;
            background: #e0e0e0;
            border-radius: 15px;
            overflow: hidden;
            margin: 20px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
        }

        .status {
            margin: 20px 0;
            padding: 15px;
            border-radius: 10px;
            font-weight: 600;
            text-align: center;
            background: #e0e0e0;
            color: #666;
        }

        .status.active {
            background: #4caf50;
            color: white;
            animation: pulse 2s infinite;
        }

        .debug-log {
            margin-top: 20px;
            padding: 15px;
            background: #f0f0f0;
            border-radius: 10px;
            font-family: monospace;
            font-size: 0.85em;
            max-height: 300px;
            overflow-y: auto;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üì± Visual Data Transfer</h1>
        
        <div class="mode-selector">
            <button class="mode-btn active" onclick="setMode('transmit')">üíª Transmit (Laptop)</button>
            <button class="mode-btn" onclick="setMode('receive')">üì± Receive (Phone)</button>
        </div>

        <!-- Transmit Section -->
        <div id="transmit-section" class="section active">
            <div class="input-area">
                <textarea id="text-input" placeholder="Enter text to transmit...">Hello from laptop!</textarea>
            </div>

            <div class="file-upload" onclick="document.getElementById('file-input').click()">
                <input type="file" id="file-input" onchange="handleFileSelect(event)">
                <p>üìÅ Click to upload a file (images, text, small files)</p>
                <p id="file-name" style="margin-top: 10px; color: #667eea; font-weight: 600;"></p>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label>Update Frequency (Hz): <span id="fps-value">5</span></label>
                    <input type="range" id="fps-slider" min="3" max="15" value="5" oninput="updateFPS(this.value)">
                </div>
                <div class="control-group">
                    <label>Grid Size</label>
                    <select id="grid-size">
                        <option value="12">12√ó12 (Fast)</option>
                        <option value="16" selected>16√ó16 (Balanced)</option>
                        <option value="20">20√ó20 (More Data)</option>
                    </select>
                </div>
            </div>

            <button class="control-btn" onclick="startTransmission()">üöÄ Start Transmission</button>

            <div class="status" id="transmit-status">Ready to transmit</div>

            <canvas id="display-canvas"></canvas>

            <div class="stats" id="transmit-stats" style="display: none;">
                <div class="stat-item">
                    <div class="stat-label">Total Bytes</div>
                    <div class="stat-value" id="total-bytes">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Frame</div>
                    <div class="stat-value" id="current-frame">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Progress</div>
                    <div class="stat-value" id="progress-percent">0%</div>
                </div>
            </div>
        </div>

        <!-- Receive Section -->
        <div id="receive-section" class="section">
            <div class="info-box">
                <strong>üì± Instructions:</strong><br>
                1. Set the same FPS value as the transmitter<br>
                2. Click "Start Camera" and allow camera access<br>
                3. Point camera at the animated grid (fill screen)<br>
                4. Keep phone STEADY and ensure good lighting<br>
                5. Check debug view below to see if detection works
            </div>

            <div class="controls">
                <div class="control-group">
                    <label>Scan Frequency (Hz): <span id="scan-fps-value">5</span></label>
                    <input type="range" id="scan-fps-slider" min="3" max="15" value="5" oninput="updateScanFPS(this.value)">
                </div>
                <div class="control-group">
                    <label>Detection Threshold: <span id="threshold-value">128</span></label>
                    <input type="range" id="threshold-slider" min="50" max="200" value="128" oninput="updateThreshold(this.value)">
                </div>
            </div>

            <button class="control-btn" id="camera-btn" onclick="toggleCamera()">üì∑ Start Camera</button>

            <div class="status" id="receive-status">Camera not started</div>

            <video id="video" autoplay playsinline></video>

            <div class="canvas-row">
                <div class="canvas-container">
                    <canvas id="scan-canvas" width="200" height="200"></canvas>
                    <p>Original Capture</p>
                </div>
                <div class="canvas-container">
                    <canvas id="processed-canvas" width="200" height="200"></canvas>
                    <p>After Processing</p>
                </div>
                <div class="canvas-container">
                    <canvas id="grid-canvas" width="200" height="200"></canvas>
                    <p>Detected Grid</p>
                </div>
            </div>

            <div class="progress-bar">
                <div class="progress-fill" id="receive-progress" style="width: 0%">0%</div>
            </div>

            <div class="stats" id="receive-stats" style="display: none;">
                <div class="stat-item">
                    <div class="stat-label">Received</div>
                    <div class="stat-value" id="received-bytes">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Expected</div>
                    <div class="stat-value" id="expected-bytes">?</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Frames OK</div>
                    <div class="stat-value" id="frames-decoded">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Errors</div>
                    <div class="stat-value" id="error-count">0</div>
                </div>
            </div>

            <div class="preview-container" id="receive-preview">
                <p style="text-align: center; color: #999;">Received data will appear here...</p>
            </div>

            <div class="debug-log" id="debug-log"></div>
        </div>
    </div>

    <script>
        let currentMode = 'transmit';
        let transmitting = false;
        let receiving = false;
        let fileData = null;
        let fileName = null;
        let fileType = null;
        
        // Transmission settings
        let fps = 5;
        let gridSize = 16;
        let transmitInterval = null;
        let currentFrameIndex = 0;
        let frames = [];
        
        // Reception state
        let scanInterval = null;
        let scanFPS = 5;
        let threshold = 128;
        let receivedFrames = {};
        let totalFrames = 0;
        let dataLength = 0;
        let receivedDataType = null;
        let errorCount = 0;
        let lastSuccessfulFrame = -1;

        function log(msg) {
            const logEl = document.getElementById('debug-log');
            const time = new Date().toLocaleTimeString();
            logEl.innerHTML += `[${time}] ${msg}<br>`;
            logEl.scrollTop = logEl.scrollHeight;
            console.log(msg);
        }

        function setMode(mode) {
            currentMode = mode;
            document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.section').forEach(sec => sec.classList.remove('active'));
            
            if (mode === 'transmit') {
                document.querySelectorAll('.mode-btn')[0].classList.add('active');
                document.getElementById('transmit-section').classList.add('active');
            } else {
                document.querySelectorAll('.mode-btn')[1].classList.add('active');
                document.getElementById('receive-section').classList.add('active');
            }
        }

        function updateFPS(value) {
            fps = parseInt(value);
            document.getElementById('fps-value').textContent = fps;
        }

        function updateScanFPS(value) {
            scanFPS = parseInt(value);
            document.getElementById('scan-fps-value').textContent = scanFPS;
        }

        function updateThreshold(value) {
            threshold = parseInt(value);
            document.getElementById('threshold-value').textContent = threshold;
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (file.size > 100000) {
                alert('File too large! Please use files under 100KB');
                return;
            }

            fileName = file.name;
            fileType = file.type;
            document.getElementById('file-name').textContent = `Selected: ${fileName} (${(file.size / 1024).toFixed(1)} KB)`;

            const reader = new FileReader();
            reader.onload = function(e) {
                fileData = new Uint8Array(e.target.result);
            };
            reader.readAsArrayBuffer(file);
        }

        function startTransmission() {
            if (transmitting) {
                stopTransmission();
                return;
            }

            const textInput = document.getElementById('text-input').value;
            let dataToSend;
            let dataType = 'text';

            if (fileData) {
                dataToSend = fileData;
                dataType = fileType || 'application/octet-stream';
            } else if (textInput) {
                dataToSend = new TextEncoder().encode(textInput);
                dataType = 'text/plain';
            } else {
                alert('Please enter text or select a file');
                return;
            }

            gridSize = parseInt(document.getElementById('grid-size').value);
            
            // Prepare frames
            frames = encodeDataToFrames(dataToSend, dataType, gridSize);
            currentFrameIndex = 0;
            
            transmitting = true;
            document.querySelector('#transmit-section .control-btn').textContent = '‚èπÔ∏è Stop Transmission';
            document.getElementById('transmit-status').textContent = 'Transmitting...';
            document.getElementById('transmit-status').className = 'status active';
            document.getElementById('transmit-stats').style.display = 'grid';
            document.getElementById('total-bytes').textContent = dataToSend.length;
            
            const canvas = document.getElementById('display-canvas');
            canvas.width = gridSize;
            canvas.height = gridSize;
            
            transmitInterval = setInterval(() => {
                if (currentFrameIndex < frames.length) {
                    drawFrame(canvas, frames[currentFrameIndex]);
                    currentFrameIndex++;
                    
                    document.getElementById('current-frame').textContent = `${currentFrameIndex}/${frames.length}`;
                    const progress = (currentFrameIndex / frames.length * 100).toFixed(1);
                    document.getElementById('progress-percent').textContent = progress + '%';
                } else {
                    currentFrameIndex = 0; // Loop
                }
            }, 1000 / fps);
        }

        function stopTransmission() {
            transmitting = false;
            clearInterval(transmitInterval);
            document.querySelector('#transmit-section .control-btn').textContent = 'üöÄ Start Transmission';
            document.getElementById('transmit-status').textContent = 'Stopped';
            document.getElementById('transmit-status').className = 'status';
        }

        function encodeDataToFrames(data, dataType, gridSize) {
            const frames = [];
            const cellsPerFrame = gridSize * gridSize;
            // Reserve: 16 cells for sync pattern, 8 for frame number, 8 for metadata = 32 cells
            const dataCellsPerFrame = cellsPerFrame - 32;
            
            // Create header
            const header = {
                len: data.length,
                type: dataType,
                grid: gridSize
            };
            const headerStr = JSON.stringify(header);
            const headerBytes = new TextEncoder().encode(headerStr);
            
            // Calculate total frames needed
            const totalDataBytes = headerBytes.length + data.length;
            const totalFramesNeeded = Math.ceil(totalDataBytes / dataCellsPerFrame);
            
            // Combine header and data
            const allData = new Uint8Array(headerBytes.length + data.length);
            allData.set(headerBytes, 0);
            allData.set(data, headerBytes.length);
            
            // Create frames
            let byteIndex = 0;
            for (let frameNum = 0; frameNum < totalFramesNeeded; frameNum++) {
                const frameData = allData.slice(byteIndex, byteIndex + dataCellsPerFrame);
                frames.push(createFrame(frameData, frameNum, totalFramesNeeded, gridSize, headerBytes.length));
                byteIndex += dataCellsPerFrame;
            }
            
            return frames;
        }

        function createFrame(data, frameNum, totalFrames, gridSize, headerLength) {
            const frame = new Uint8Array(gridSize * gridSize);
            
            // Sync pattern - strong alternating pattern (16 cells, 4x4 checkerboard)
            for (let i = 0; i < 16; i++) {
                const row = Math.floor(i / 4);
                const col = i % 4;
                frame[row * gridSize + col] = ((row + col) % 2 === 0) ? 255 : 0;
            }
            
            // Frame number (4 cells = 32 bits)
            frame[gridSize * 4] = (frameNum >> 24) & 0xFF;
            frame[gridSize * 4 + 1] = (frameNum >> 16) & 0xFF;
            frame[gridSize * 4 + 2] = (frameNum >> 8) & 0xFF;
            frame[gridSize * 4 + 3] = frameNum & 0xFF;
            
            // Total frames (4 cells)
            frame[gridSize * 4 + 4] = (totalFrames >> 24) & 0xFF;
            frame[gridSize * 4 + 5] = (totalFrames >> 16) & 0xFF;
            frame[gridSize * 4 + 6] = (totalFrames >> 8) & 0xFF;
            frame[gridSize * 4 + 7] = totalFrames & 0xFF;
            
            // Data length in this frame (2 cells) and header length (2 cells)
            frame[gridSize * 5] = (data.length >> 8) & 0xFF;
            frame[gridSize * 5 + 1] = data.length & 0xFF;
            frame[gridSize * 5 + 2] = (headerLength >> 8) & 0xFF;
            frame[gridSize * 5 + 3] = headerLength & 0xFF;
            
            // Fill with data starting from position 32
            for (let i = 0; i < data.length; i++) {
                frame[32 + i] = data[i];
            }
            
            return frame;
        }

        function drawFrame(canvas, frameData) {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.createImageData(canvas.width, canvas.height);
            
            for (let i = 0; i < frameData.length; i++) {
                const idx = i * 4;
                const val = frameData[i];
                imageData.data[idx] = val;
                imageData.data[idx + 1] = val;
                imageData.data[idx + 2] = val;
                imageData.data[idx + 3] = 255;
            }
            
            ctx.putImageData(imageData, 0, 0);
        }

        // Receiver functions
        async function toggleCamera() {
            if (receiving) {
                stopCamera();
            } else {
                await startCamera();
            }
        }

        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { 
                        facingMode: 'environment',
                        width: { ideal: 1920 },
                        height: { ideal: 1080 }
                    } 
                });
                
                const video = document.getElementById('video');
                video.srcObject = stream;
                
                receiving = true;
                document.getElementById('camera-btn').textContent = '‚èπÔ∏è Stop Camera';
                document.getElementById('receive-status').textContent = 'Scanning...';
                document.getElementById('receive-status').className = 'status active';
                document.getElementById('receive-stats').style.display = 'grid';
                
                receivedFrames = {};
                totalFrames = 0;
                dataLength = 0;
                errorCount = 0;
                lastSuccessfulFrame = -1;
                
                log('Camera started, waiting for data...');
                
                // Wait for video to be ready
                video.addEventListener('loadedmetadata', () => {
                    log(`Video ready: ${video.videoWidth}x${video.videoHeight}`);
                    scanInterval = setInterval(scanFrame, 1000 / scanFPS);
                });
            } catch (err) {
                alert('Camera error: ' + err.message);
                log('Camera error: ' + err.message);
            }
        }

        function stopCamera() {
            receiving = false;
            clearInterval(scanInterval);
            
            const video = document.getElementById('video');
            if (video.srcObject) {
                video.srcObject.getTracks().forEach(track => track.stop());
                video.srcObject = null;
            }
            
            document.getElementById('camera-btn').textContent = 'üì∑ Start Camera';
            document.getElementById('receive-status').textContent = 'Stopped';
            document.getElementById('receive-status').className = 'status';
            log('Camera stopped');
        }

        function scanFrame() {
            const video = document.getElementById('video');
            if (video.readyState !== video.HAVE_ENOUGH_DATA) return;
            
            const scanCanvas = document.getElementById('scan-canvas');
            const processedCanvas = document.getElementById('processed-canvas');
            const gridCanvas = document.getElementById('grid-canvas');
            
            const ctx = scanCanvas.getContext('2d');
            
            // Capture center portion of video
            const captureSize = Math.min(video.videoWidth, video.videoHeight);
            const sx = (video.videoWidth - captureSize) / 2;
            const sy = (video.videoHeight - captureSize) / 2;
            
            scanCanvas.width = 200;
            scanCanvas.height = 200;
            ctx.drawImage(video, sx, sy, captureSize, captureSize, 0, 0, 200, 200);
            
            // Process image: convert to grayscale and apply threshold
            const imageData = ctx.getImageData(0, 0, 200, 200);
            const processed = processImage(imageData);
            
            // Show processed image
            const pCtx = processedCanvas.getContext('2d');
            processedCanvas.width = 200;
            processedCanvas.height = 200;
            pCtx.putImageData(processed, 0, 0);
            
            // Try to detect grid for each possible size
            for (let size of [16, 12, 20]) {
                const gridData = extractGrid(processed, size);
                if (gridData) {
                    // Show detected grid
                    const gCtx = gridCanvas.getContext('2d');
                    gridCanvas.width = size * 10;
                    gridCanvas.height = size * 10;
                    drawDetectedGrid(gCtx, gridData, size);
                    
                    // Try to decode frame
                    const frame = decodeFrame(gridData, size);
                    if (frame) {
                        processReceivedFrame(frame);
                        return;
                    }
                }
            }
        }

        function processImage(imageData) {
            const data = imageData.data;
            const processed = new ImageData(imageData.width, imageData.height);
            
            // Convert to grayscale
            const gray = new Uint8Array(data.length / 4);
            for (let i = 0; i < data.length; i += 4) {
                gray[i / 4] = Math.round(0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2]);
            }
            
            // Apply adaptive threshold
            for (let i = 0; i < gray.length; i++) {
                const val = gray[i] > threshold ? 255 : 0;
                processed.data[i * 4] = val;
                processed.data[i * 4 + 1] = val;
                processed.data[i * 4 + 2] = val;
                processed.data[i * 4 + 3] = 255;
            }
            
            return processed;
        }

        function extractGrid(imageData, gridSize) {
            const data = imageData.data;
            const imgWidth = imageData.width;
            const imgHeight = imageData.height;
            
            const cellWidth = imgWidth / gridSize;
            const cellHeight = imgHeight / gridSize;
            
            const gridData = new Uint8Array(gridSize * gridSize);
            
            // Sample each cell
            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                    // Sample center of cell
                    const x = Math.floor(col * cellWidth + cellWidth / 2);
                    const y = Math.floor(row * cellHeight + cellHeight / 2);
                    const idx = (y * imgWidth + x) * 4;
                    gridData[row * gridSize + col] = data[idx]; // Already thresholded to 0 or 255
                }
            }
            
            // Verify sync pattern
            let syncScore = 0;
            for (let i = 0; i < 16; i++) {
                const row = Math.floor(i / 4);
                const col = i % 4;
                const expected = ((row + col) % 2 === 0) ? 255 : 0;
                const actual = gridData[row * gridSize + col];
                if (actual === expected) syncScore++;
            }
            
            if (syncScore >= 14) { // At least 14/16 correct
                return gridData;
            }
            
            return null;
        }

        function drawDetectedGrid(ctx, gridData, gridSize) {
            const cellSize = 10;
            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                    const val = gridData[row * gridSize + col];
                    ctx.fillStyle = val > 128 ? 'white' : 'black';
                    ctx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);
                }
            }
        }

        function decodeFrame(gridData, gridSize) {
            try {
                // Extract frame number (4 bytes starting at position gridSize*4)
                const frameNumBytes = [];
                for (let i = 0; i < 4; i++) {
                    frameNumBytes.push(gridData[gridSize * 4 + i]);
                }
                const frameNum = (frameNumBytes[0] << 24) | (frameNumBytes[1] << 16) | 
                                (frameNumBytes[2] << 8) | frameNumBytes[3];
                
                // Extract total frames
                const totalFramesBytes = [];
                for (let i = 0; i < 4; i++) {
                    totalFramesBytes.push(gridData[gridSize * 4 + 4 + i]);
                }
                const totalFramesValue = (totalFramesBytes[0] << 24) | (totalFramesBytes[1] << 16) | 
                                         (totalFramesBytes[2] << 8) | totalFramesBytes[3];
                
                // Extract data length and header length
                const dataLen = (gridData[gridSize * 5] << 8) | gridData[gridSize * 5 + 1];
                const headerLen = (gridData[gridSize * 5 + 2] << 8) | gridData[gridSize * 5 + 3];
                
                // Sanity checks
                if (frameNum < 0 || frameNum > 10000) return null;
                if (totalFramesValue < 1 || totalFramesValue > 10000) return null;
                if (dataLen < 0 || dataLen > 1000) return null;
                
                // Extract payload starting from position 32
                const payload = gridData.slice(32, 32 + dataLen);
                
                return {
                    frameNum,
                    totalFrames: totalFramesValue,
                    payload,
                    headerLength: headerLen
                };
            } catch (e) {
                errorCount++;
                document.getElementById('error-count').textContent = errorCount;
                return null;
            }
        }

        function processReceivedFrame(frame) {
            // Skip duplicate frames
            if (receivedFrames[frame.frameNum]) return;
            
            receivedFrames[frame.frameNum] = frame;
            totalFrames = frame.totalFrames;
            
            const framesReceived = Object.keys(receivedFrames).length;
            document.getElementById('frames-decoded').textContent = framesReceived;
            
            if (frame.frameNum !== lastSuccessfulFrame) {
                log(`‚úì Frame ${frame.frameNum}/${frame.totalFrames} (${frame.payload.length} bytes)`);
                lastSuccessfulFrame = frame.frameNum;
            }
            
            // Update progress
            const progress = Math.min(100, (framesReceived / totalFrames * 100));
            document.getElementById('receive-progress').style.width = progress + '%';
            document.getElementById('receive-progress').textContent = progress.toFixed(0) + '%';
            
            // Try to reconstruct data
            if (framesReceived >= totalFrames) {
                reconstructData(frame.headerLength);
            } else {
                // Show partial reconstruction
                reconstructData(frame.headerLength);
            }
        }

        function reconstructData(headerLength) {
            // Sort frames by frame number
            const sortedFrames = Object.keys(receivedFrames)
                .map(k => parseInt(k))
                .sort((a, b) => a - b)
                .map(k => receivedFrames[k]);
            
            // Concatenate all payloads
            let allBytes = [];
            for (const frame of sortedFrames) {
                allBytes.push(...frame.payload);
            }
            
            // Split header and data
            const headerBytes = allBytes.slice(0, headerLength);
            const dataBytes = allBytes.slice(headerLength);
            
            // Parse header
            try {
                const headerStr = new TextDecoder().decode(new Uint8Array(headerBytes));
                const header = JSON.parse(headerStr);
                
                dataLength = header.len;
                receivedDataType = header.type;
                
                document.getElementById('expected-bytes').textContent = dataLength;
                document.getElementById('received-bytes').textContent = dataBytes.length;
                
                // Truncate to expected length
                const finalData = new Uint8Array(dataBytes.slice(0, dataLength));
                
                // Display data
                const preview = document.getElementById('receive-preview');
                preview.innerHTML = '';
                
                if (receivedDataType && receivedDataType.startsWith('image/')) {
                    const blob = new Blob([finalData], { type: receivedDataType });
                    const url = URL.createObjectURL(blob);
                    const img = document.createElement('img');
                    img.src = url;
                    img.style.maxWidth = '100%';
                    preview.appendChild(img);
                    log('üì∑ Image reconstructed!');
                } else {
                    try {
                        const text = new TextDecoder().decode(finalData);
                        const pre = document.createElement('pre');
                        pre.textContent = text;
                        preview.appendChild(pre);
                        log(`üìù Text: "${text}"`);
                    } catch (e) {
                        preview.innerHTML = `<p>Binary data (${finalData.length} bytes)</p>`;
                        log(`üì¶ Binary data: ${finalData.length} bytes`);
                    }
                }
                
                // Check if complete
                if (dataBytes.length >= dataLength && Object.keys(receivedFrames).length >= totalFrames) {
                    document.getElementById('receive-status').textContent = '‚úÖ Transfer Complete!';
                    document.getElementById('receive-status').className = 'status';
                    log('‚úÖ Transfer complete!');
                }
            } catch (e) {
                log('‚ö†Ô∏è Waiting for more frames...');
            }
        }

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Color Flash Data Transfer</title>
    <style>
        :root {
            --primary-color: #6a11cb;
            --secondary-color: #2575fc;
            --background-color: #f0f2f5;
            --container-bg: #ffffff;
            --text-color: #333;
            --light-gray: #e9ecef;
            --border-radius: 12px;
            --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-family);
            background-color: var(--background-color);
            color: var(--text-color);
            display: flex;
            min-height: 100vh;
            overflow: hidden;
        }

        /* --- Layout --- */
        #flash-container {
            flex: 1;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background-color 0.05s linear;
            position: relative;
        }

        #controls-container {
            flex: 2;
            padding: 2rem 3rem;
            background-color: var(--container-bg);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }
        
        #flash-info {
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 1.1rem;
            text-align: center;
            opacity: 0;
            transition: opacity 0.3s;
        }

        #flash-container.transmitting #flash-info {
            opacity: 1;
        }


        /* --- Controls --- */
        .container-wrapper {
            max-width: 700px;
            margin: auto;
            width: 100%;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 2rem;
            font-weight: 700;
            color: var(--primary-color);
        }

        .mode-selector {
            display: flex;
            background: var(--light-gray);
            border-radius: var(--border-radius);
            padding: 5px;
            margin-bottom: 1.5rem;
        }

        .mode-btn {
            flex: 1;
            padding: 12px;
            background: transparent;
            border: none;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            color: #555;
            border-radius: 9px;
        }

        .mode-btn.active {
            background: var(--container-bg);
            color: var(--primary-color);
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .section { display: none; }
        .section.active { display: block; }
        .input-group { margin-bottom: 1.5rem; }

        label, .label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 600;
        }
        
        textarea, input[type="file"] {
            width: 100%;
            padding: 12px;
            border: 2px solid var(--light-gray);
            border-radius: 8px;
            font-size: 1rem;
            font-family: inherit;
            transition: border-color 0.3s;
            background: #fafafa;
        }

        textarea:focus, input:focus {
            outline: none;
            border-color: var(--secondary-color);
        }
        
        .options {
            padding: 1rem;
            background: var(--light-gray);
            border-radius: var(--border-radius);
            margin-bottom: 1.5rem;
            display: flex;
            flex-wrap: wrap;
            gap: 1.5rem;
        }
        
        .option-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .option-item input[type="number"] {
            width: 70px;
            padding: 6px;
            border: 2px solid #ccc;
            border-radius: 6px;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 28px;
        }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 28px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 20px; width: 20px;
            left: 4px; bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider { background-color: var(--secondary-color); }
        input:checked + .slider:before { transform: translateX(22px); }


        .main-btn {
            padding: 15px 30px;
            background: linear-gradient(135deg, var(--secondary-color) 0%, var(--primary-color) 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            width: 100%;
            margin-bottom: 10px;
        }
        .main-btn:hover { transform: translateY(-2px); box-shadow: 0 4px 15px rgba(0,0,0,0.15); }
        .main-btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; box-shadow: none;}
        
        .stop-btn { background: #e74c3c; }

        /* --- Stats & Previews --- */
        .stats {
            display: grid;
            grid-template-columns: 1fr;
            gap: 15px;
            margin-top: 20px;
            padding: 20px;
            background: var(--light-gray);
            border-radius: var(--border-radius);
        }

        #progress-bar-container {
            width: 100%;
            height: 20px;
            background: #ddd;
            border-radius: 10px;
            overflow: hidden;
        }
        #progress-bar {
            width: 0%;
            height: 100%;
            background: linear-gradient(135deg, var(--secondary-color) 0%, var(--primary-color) 100%);
            transition: width 0.2s linear;
        }
        
        #receiver-view {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        #cameraView {
            width: 100%;
            max-width: 400px;
            border-radius: var(--border-radius);
            margin-bottom: 1rem;
            border: 2px solid var(--light-gray);
        }

        #received-preview {
            margin-top: 1rem;
            padding: 20px;
            background: var(--light-gray);
            border-radius: var(--border-radius);
            min-height: 100px;
            width: 100%;
        }

        #received-content a {
            display: inline-block;
            margin-top: 10px;
            padding: 10px 15px;
            background: var(--primary-color);
            color: white;
            text-decoration: none;
            border-radius: 6px;
        }
        #received-content img {
            max-width: 100%;
            border-radius: 8px;
            margin-top: 10px;
        }
        #received-content pre {
            white-space: pre-wrap;
            word-break: break-all;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div id="flash-container">
        <div id="flash-info">Place receiver in the left 1/3 of the screen</div>
    </div>

    <div id="controls-container">
        <div class="container-wrapper">
            <h1>Offline Data Transfer</h1>

            <div class="mode-selector">
                <button class="mode-btn active" onclick="switchMode('send')">ðŸ“¤ Send</button>
                <button class="mode-btn" onclick="switchMode('receive')">ðŸ“¥ Receive</button>
            </div>

            <div id="sendMode" class="section active">
                <div class="input-group">
                    <label class="label">Data Type:</label>
                    <div class="mode-selector">
                        <button class="data-type-btn active" onclick="switchDataType('text')">Text</button>
                        <button class="data-type-btn" onclick="switchDataType('file')">File</button>
                    </div>
                </div>

                <div id="textInput" class="input-group">
                    <label for="inputText">Enter Text:</label>
                    <textarea id="inputText" placeholder="Type your message here..."></textarea>
                </div>

                <div id="fileInput" class="input-group" style="display: none;">
                    <label for="inputFile">Select File:</label>
                    <input type="file" id="inputFile">
                </div>

                <div class="options">
                    <div class="option-item">
                        <label for="bitSpeed">Speed (ms/flash):</label>
                        <input type="number" id="bitSpeed" value="100" min="20" max="1000" step="10">
                    </div>
                    <div class="option-item">
                        <label for="experimentalMode">Experimental Mode (8 colors):</label>
                        <label class="toggle-switch">
                            <input type="checkbox" id="experimentalMode">
                            <span class="slider"></span>
                        </label>
                    </div>
                </div>

                <button id="transmitBtn" class="main-btn" onclick="startTransmission()">Start Transmission</button>

                <div id="sendStats" class="stats" style="display: none;">
                    <div id="progress-info">
                        <span id="progress-text">0%</span> - <span id="data-size">0 bytes</span>
                    </div>
                    <div id="progress-bar-container">
                        <div id="progress-bar"></div>
                    </div>
                    <div id="time-remaining">Time Remaining: --</div>
                </div>
            </div>

            <div id="receiveMode" class="section">
                 <div id="receiver-view">
                    <p style="text-align: center; margin-bottom: 1rem;">Position camera over the flashing area on the other screen.</p>
                    <video id="cameraView" autoplay playsinline muted></video>
                    <button id="receiveBtn" class="main-btn" onclick="startColorReceive()">Start Receiving</button>
                    <button id="stopReceiveBtn" class="main-btn stop-btn" onclick="stopReceiving()" style="display:none;">Stop Receiving</button>
                </div>

                <div id="receiveStats" class="stats" style="display: none;">
                    <div id="receive-status">Status: Idle</div>
                    <div id="progress-bar-container">
                        <div id="receive-progress-bar" style="width:0%; height: 100%; background: var(--primary-color);"></div>
                    </div>
                    <div id="receive-progress-text">0 / 0 bits</div>
                </div>

                <div id="received-preview">
                    <div class="label">Received Data:</div>
                    <div id="received-content">Awaiting transmission...</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- State Management ---
        let currentMode = 'send';
        let currentDataType = 'text';
        let transmissionInterval = null;
        let receivingActive = false;
        let videoStream = null;

        // --- Constants ---
        const BITS_PER_CHAR = 16; // Using UTF-16
        const SYNC_PULSE = [0, 7, 0, 7]; // A distinct start sequence (black, white, black, white) for experimental mode
        const HEADER_TERMINATOR = '\n';

        // --- Color Mappings ---
        const STANDARD_COLORS = { 0: '#ff0000', 1: '#0000ff' }; // Red: 0, Blue: 1
        const EXPERIMENTAL_COLORS = { // Maps 3-bit value to a color
            0: '#000000', // 000: Black
            1: '#ff0000', // 001: Red
            2: '#00ff00', // 010: Green
            3: '#ffff00', // 011: Yellow
            4: '#0000ff', // 100: Blue
            5: '#ff00ff', // 101: Magenta
            6: '#00ffff', // 110: Cyan
            7: '#ffffff', // 111: White
        };

        // --- UI Switching ---
        function switchMode(mode) {
            currentMode = mode;
            document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            document.getElementById('sendMode').classList.toggle('active', mode === 'send');
            document.getElementById('receiveMode').classList.toggle('active', mode === 'receive');
            
            stopTransmission();
            stopReceiving();
        }

        function switchDataType(type) {
            currentDataType = type;
            document.querySelectorAll('.data-type-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            document.getElementById('textInput').style.display = type === 'text' ? 'block' : 'none';
            document.getElementById('fileInput').style.display = type === 'file' ? 'block' : 'none';
        }

        // --- Data Handling ---
        function stringToBits(str) {
            const bits = [];
            for (let i = 0; i < str.length; i++) {
                const charCode = str.charCodeAt(i);
                for (let j = BITS_PER_CHAR - 1; j >= 0; j--) {
                    bits.push((charCode >> j) & 1);
                }
            }
            return bits;
        }

        function bitsToString(bits) {
            let str = '';
            for (let i = 0; i < bits.length; i += BITS_PER_CHAR) {
                if (i + BITS_PER_CHAR > bits.length) break;
                let charCode = 0;
                for (let j = 0; j < BITS_PER_CHAR; j++) {
                    charCode = (charCode << 1) | bits[i + j];
                }
                str += String.fromCharCode(charCode);
            }
            return str;
        }

        async function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = () => resolve(reader.result);
                reader.onerror = error => reject(error);
            });
        }
        
        // --- SENDER LOGIC ---
        async function prepareDataForTransmission() {
            let payload = '';
            let mimeType = 'text/plain';
            let fileName = 'text.txt';

            if (currentDataType === 'text') {
                payload = document.getElementById('inputText').value;
                if (!payload) { alert('Please enter some text.'); return null; }
            } else {
                const file = document.getElementById('inputFile').files[0];
                if (!file) { alert('Please select a file.'); return null; }
                const base64Data = await fileToBase64(file);
                payload = base64Data.split(',')[1]; // Strip the data URL prefix
                mimeType = file.type || 'application/octet-stream';
                fileName = file.name;
            }

            const payloadBits = stringToBits(payload);
            const header = `${mimeType}|${fileName}|${payloadBits.length}${HEADER_TERMINATOR}`;
            const headerBits = stringToBits(header);
            
            return headerBits.concat(payloadBits);
        }

        async function startTransmission() {
            if (transmissionInterval) stopTransmission();

            const bitStream = await prepareDataForTransmission();
            if (!bitStream) return;

            const flashContainer = document.getElementById('flash-container');
            const flashInfo = document.getElementById('flash-info');
            const transmitBtn = document.getElementById('transmitBtn');
            const sendStats = document.getElementById('sendStats');
            const bitSpeed = parseInt(document.getElementById('bitSpeed').value);
            const isExperimental = document.getElementById('experimentalMode').checked;
            const bitsPerFlash = isExperimental ? 3 : 1;
            const colors = isExperimental ? EXPERIMENTAL_COLORS : STANDARD_COLORS;

            let currentBitIndex = 0;
            const totalBits = bitStream.length;
            const startTime = Date.now();
            
            // Add sync pulse for experimental mode
            const transmissionQueue = isExperimental ? [...SYNC_PULSE] : [];
            for (let i = 0; i < totalBits; i += bitsPerFlash) {
                if (i + bitsPerFlash > totalBits) {
                    // Pad with zeros if not a full chunk
                    const remainingBits = bitStream.slice(i);
                    while(remainingBits.length < bitsPerFlash) remainingBits.push(0);
                    let value = 0;
                    remainingBits.forEach(b => value = (value << 1) | b);
                    transmissionQueue.push(value);
                } else {
                    let value = 0;
                    for (let j = 0; j < bitsPerFlash; j++) {
                        value = (value << 1) | bitStream[i + j];
                    }
                    transmissionQueue.push(value);
                }
            }

            let queueIndex = 0;
            transmitBtn.disabled = true;
            flashContainer.classList.add('transmitting');
            sendStats.style.display = 'grid';
            document.getElementById('data-size').textContent = `${Math.ceil(totalBits / 8)} bytes`;

            transmissionInterval = setInterval(() => {
                if (queueIndex >= transmissionQueue.length) {
                    stopTransmission(true); // true for successful completion
                    return;
                }

                const value = transmissionQueue[queueIndex];
                flashContainer.style.backgroundColor = colors[value];

                // Update progress
                if (isExperimental && queueIndex < SYNC_PULSE.length) {
                    flashInfo.textContent = "SYNC PULSE";
                } else {
                    currentBitIndex = isExperimental ? (queueIndex - SYNC_PULSE.length) * bitsPerFlash : queueIndex;
                    currentBitIndex = Math.min(currentBitIndex, totalBits);

                    const progress = (currentBitIndex / totalBits) * 100;
                    document.getElementById('progress-bar').style.width = `${progress}%`;
                    document.getElementById('progress-text').textContent = `${progress.toFixed(1)}%`;
                    
                    const elapsedMs = Date.now() - startTime;
                    const bitsPerMs = currentBitIndex / elapsedMs;
                    const remainingBits = totalBits - currentBitIndex;
                    const remainingMs = remainingBits / bitsPerMs;
                    if(isFinite(remainingMs) && remainingMs > 0) {
                        document.getElementById('time-remaining').textContent = `Time Remaining: ${Math.ceil(remainingMs / 1000)}s`;
                    }
                    
                    flashInfo.textContent = `Transmitting Bit ${currentBitIndex} / ${totalBits}`;
                }

                queueIndex++;
            }, bitSpeed);
        }

        function stopTransmission(isSuccess = false) {
            clearInterval(transmissionInterval);
            transmissionInterval = null;
            document.getElementById('transmitBtn').disabled = false;
            
            const flashContainer = document.getElementById('flash-container');
            const flashInfo = document.getElementById('flash-info');
            
            flashInfo.textContent = isSuccess ? "Transmission Complete!" : "Transmission Stopped.";
            flashContainer.style.backgroundColor = isSuccess ? '#2ecc71' : '#e74c3c'; // Green for success, Red for stop

            setTimeout(() => {
                flashContainer.classList.remove('transmitting');
                flashContainer.style.backgroundColor = '#000';
                document.getElementById('sendStats').style.display = 'none';
            }, 2000);
        }

        // --- RECEIVER LOGIC ---
        async function startColorReceive() {
            if (receivingActive) return;

            const video = document.getElementById('cameraView');
            try {
                videoStream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: 'environment', width: { ideal: 640 }, height: { ideal: 480 } }
                });
                video.srcObject = videoStream;
                await video.play();
                
                receivingActive = true;
                document.getElementById('receiveBtn').style.display = 'none';
                document.getElementById('stopReceiveBtn').style.display = 'block';
                document.getElementById('receiveStats').style.display = 'grid';
                document.getElementById('received-content').innerHTML = 'Awaiting transmission...';
                
                startFrameProcessor(video);
            } catch (err) {
                alert('Could not access camera: ' + err.message);
            }
        }

        function stopReceiving() {
            receivingActive = false;
            if (videoStream) {
                videoStream.getTracks().forEach(track => track.stop());
            }
            document.getElementById('receiveBtn').style.display = 'block';
            document.getElementById('stopReceiveBtn').style.display = 'none';
            document.getElementById('receive-status').textContent = 'Status: Stopped';
        }

        function startFrameProcessor(video) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d', { willReadFrequently: true });

            let state = 'WAITING_FOR_SYNC'; // WAITING_FOR_SYNC, READING_HEADER, READING_PAYLOAD, DONE
            let headerInfo = null;
            let receivedBits = [];
            let lastColorValue = -1;
            let lastColorTimestamp = 0;
            const debounceTime = parseInt(document.getElementById('bitSpeed').value) * 0.75;
            
            const statusEl = document.getElementById('receive-status');
            const progressTextEl = document.getElementById('receive-progress-text');
            const progressBarEl = document.getElementById('receive-progress-bar');
            
            function processBit(bitValue) {
                if(state === 'WAITING_FOR_SYNC'){
                    // Simplified sync check: Look for a non-black color
                     if(bitValue > 0) {
                        state = 'READING_HEADER';
                        statusEl.textContent = 'Status: Reading Header';
                     }
                     return;
                }

                const bitsPerFlash = (bitValue > 1) ? 3 : 1; // Inferring experimental mode
                let bits = [];
                if (bitsPerFlash === 1) {
                    bits.push(bitValue);
                } else {
                    bits = [
                        (bitValue >> 2) & 1, 
                        (bitValue >> 1) & 1, 
                        bitValue & 1
                    ];
                }

                receivedBits.push(...bits);

                if (state === 'READING_HEADER') {
                    const receivedString = bitsToString(receivedBits);
                    if (receivedString.includes(HEADER_TERMINATOR)) {
                        const headerStr = receivedString.split(HEADER_TERMINATOR)[0];
                        const parts = headerStr.split('|');
                        if(parts.length === 3){
                            headerInfo = {
                                mime: parts[0],
                                name: parts[1],
                                totalBits: parseInt(parts[2])
                            };
                            // Remove header bits from buffer
                            const headerBitLength = stringToBits(headerStr + HEADER_TERMINATOR).length;
                            receivedBits = receivedBits.slice(headerBitLength);

                            state = 'READING_PAYLOAD';
                            statusEl.textContent = `Status: Receiving file: ${headerInfo.name}`;
                        } else {
                            // Invalid header, reset
                            state = 'WAITING_FOR_SYNC';
                            receivedBits = [];
                        }
                    }
                }

                if (state === 'READING_PAYLOAD') {
                    const progress = (receivedBits.length / headerInfo.totalBits) * 100;
                    progressBarEl.style.width = `${progress}%`;
                    progressTextEl.textContent = `${receivedBits.length} / ${headerInfo.totalBits} bits`;

                    if (receivedBits.length >= headerInfo.totalBits) {
                        state = 'DONE';
                        statusEl.textContent = 'Status: Complete!';
                        progressBarEl.style.width = '100%';
                        processFinalData();
                        stopReceiving();
                    }
                }
            }

            function processFinalData() {
                const payloadBits = receivedBits.slice(0, headerInfo.totalBits);
                const payloadStr = bitsToString(payloadBits);
                const receivedContentEl = document.getElementById('received-content');
                
                try {
                    if (headerInfo.mime.startsWith('image/')) {
                        const dataUrl = `data:${headerInfo.mime};base64,${btoa(payloadStr)}`;
                        receivedContentEl.innerHTML = `<img src="${dataUrl}" alt="Received Image">`;
                    } else if (headerInfo.mime === 'text/plain') {
                        receivedContentEl.innerHTML = `<pre>${payloadStr}</pre>`;
                    } else {
                        const dataUrl = `data:${headerInfo.mime};base64,${btoa(payloadStr)}`;
                        receivedContentEl.innerHTML = `<p>Received file: <b>${headerInfo.name}</b></p>`;
                        const downloadLink = document.createElement('a');
                        downloadLink.href = dataUrl;
                        downloadLink.download = headerInfo.name;
                        downloadLink.textContent = 'Download File';
                        receivedContentEl.appendChild(downloadLink);
                    }
                } catch(e) {
                     receivedContentEl.innerHTML = `<p>Error decoding data. It might be corrupted.</p><pre>${e.message}</pre>`;
                }
            }

            function captureFrame() {
                if (!receivingActive) return;

                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                // Capture from the center of the camera view
                const captureSize = 50;
                const sx = (canvas.width / 2) - (captureSize / 2);
                const sy = (canvas.height / 2) - (captureSize / 2);
                ctx.drawImage(video, sx, sy, captureSize, captureSize, 0, 0, captureSize, captureSize);
                
                const imageData = ctx.getImageData(0, 0, captureSize, captureSize);
                const data = imageData.data;
                let r = 0, g = 0, b = 0;
                for (let i = 0; i < data.length; i += 4) {
                    r += data[i]; g += data[i + 1]; b += data[i + 2];
                }
                const pixelCount = data.length / 4;
                r = Math.round(r / pixelCount);
                g = Math.round(g / pixelCount);
                b = Math.round(b / pixelCount);

                const colorThreshold = 80;
                const isRed = r > colorThreshold && g < colorThreshold && b < colorThreshold;
                const isGreen = g > colorThreshold && r < colorThreshold && b < colorThreshold;
                const isBlue = b > colorThreshold && r < colorThreshold && g < colorThreshold;

                let currentValue = -1;
                // Experimental Mode Detection (3 bits)
                if (isRed || isGreen || isBlue) {
                    const bit1 = isRed ? 1 : 0;
                    const bit2 = isGreen ? 1 : 0;
                    const bit3 = isBlue ? 1 : 0;
                    currentValue = (bit3 << 2) | (bit2 << 1) | bit1;
                }
                // Standard Mode (1 bit)
                else if (r > b + colorThreshold) { currentValue = 0; } // Red
                else if (b > r + colorThreshold) { currentValue = 1; } // Blue

                // Black/White detection for experimental mode sync & colors
                if(r > 180 && g > 180 && b > 180) currentValue = 7; // White
                if(r < 50 && g < 50 && b < 50) currentValue = 0; // Black
                
                const now = Date.now();
                if (currentValue !== -1 && currentValue !== lastColorValue && now - lastColorTimestamp > debounceTime) {
                    lastColorValue = currentValue;
                    lastColorTimestamp = now;
                    processBit(currentValue);
                }

                requestAnimationFrame(captureFrame);
            }

            captureFrame();
        }

        // --- Init ---
        window.addEventListener('beforeunload', () => {
            stopTransmission();
            stopReceiving();
        });

    </script>
</body>
</html>

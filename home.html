<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visual Data Transfer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        h1 {
            text-align: center;
            color: #667eea;
            margin-bottom: 30px;
            font-size: 2.5em;
        }

        .mode-selector {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
            justify-content: center;
        }

        .mode-btn {
            padding: 15px 40px;
            border: none;
            border-radius: 10px;
            font-size: 1.1em;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
            background: #e0e0e0;
            color: #333;
        }

        .mode-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            transform: scale(1.05);
        }

        .section {
            display: none;
        }

        .section.active {
            display: block;
        }

        .input-area {
            margin-bottom: 20px;
        }

        textarea {
            width: 100%;
            padding: 15px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            font-size: 1em;
            resize: vertical;
            min-height: 120px;
            font-family: inherit;
        }

        .file-upload {
            margin: 20px 0;
            padding: 30px;
            border: 3px dashed #667eea;
            border-radius: 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }

        .file-upload:hover {
            background: rgba(102, 126, 234, 0.1);
        }

        .file-upload input {
            display: none;
        }

        .controls {
            display: flex;
            gap: 15px;
            margin: 20px 0;
            align-items: center;
            flex-wrap: wrap;
        }

        .control-group {
            flex: 1;
            min-width: 200px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #555;
        }

        input[type="range"] {
            width: 100%;
        }

        select {
            width: 100%;
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1em;
        }

        .control-btn {
            width: 100%;
            padding: 15px;
            border: none;
            border-radius: 10px;
            font-size: 1.2em;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            margin-top: 10px;
        }

        .control-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
        }

        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #display-canvas {
            width: 100%;
            max-width: 600px;
            height: 600px;
            margin: 20px auto;
            display: block;
            background: black;
            border: 8px solid #FF0000;
            border-radius: 10px;
            image-rendering: pixelated;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .stat-item {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 15px;
            border-radius: 10px;
            color: white;
            text-align: center;
        }

        .stat-label {
            font-size: 0.9em;
            opacity: 0.9;
        }

        .stat-value {
            font-size: 1.5em;
            font-weight: 600;
            margin-top: 5px;
        }

        .video-container {
            position: relative;
            max-width: 640px;
            margin: 20px auto;
        }

        #video {
            width: 100%;
            height: auto;
            display: block;
            border-radius: 10px;
            border: 4px solid #333;
        }

        #debug-canvas {
            width: 100%;
            margin-top: 10px;
            border: 2px solid #333;
            border-radius: 5px;
        }

        .detection-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .info-box {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            border-left: 4px solid #2196f3;
        }

        .preview-container {
            margin: 20px 0;
            padding: 20px;
            background: #f5f5f5;
            border-radius: 10px;
            min-height: 200px;
        }

        .preview-container img {
            max-width: 100%;
            border-radius: 10px;
        }

        .preview-container pre {
            white-space: pre-wrap;
            word-wrap: break-word;
            font-family: 'Courier New', monospace;
        }

        .progress-bar {
            width: 100%;
            height: 30px;
            background: #e0e0e0;
            border-radius: 15px;
            overflow: hidden;
            margin: 20px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
        }

        .status {
            margin: 20px 0;
            padding: 15px;
            border-radius: 10px;
            font-weight: 600;
            text-align: center;
            background: #e0e0e0;
            color: #666;
        }

        .status.active {
            background: #4caf50;
            color: white;
            animation: pulse 2s infinite;
        }

        .status.warning {
            background: #ff9800;
            color: white;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .log {
            background: #f0f0f0;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 0.85em;
            max-height: 150px;
            overflow-y: auto;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üì± Visual Data Transfer</h1>
        
        <div class="mode-selector">
            <button class="mode-btn active" onclick="setMode('transmit')">üíª Transmit (Laptop)</button>
            <button class="mode-btn" onclick="setMode('receive')">üì± Receive (Phone)</button>
        </div>

        <!-- Transmit Section -->
        <div id="transmit-section" class="section active">
            <div class="input-area">
                <textarea id="text-input" placeholder="Enter text to transmit...">Hello World!</textarea>
            </div>

            <div class="file-upload" onclick="document.getElementById('file-input').click()">
                <input type="file" id="file-input" onchange="handleFileSelect(event)">
                <p>üìÅ Click to upload a file (images, text, small files)</p>
                <p id="file-name" style="margin-top: 10px; color: #667eea; font-weight: 600;"></p>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label>Update Frequency (Hz): <span id="fps-value">8</span></label>
                    <input type="range" id="fps-slider" min="4" max="15" value="8" oninput="updateFPS(this.value)">
                </div>
                <div class="control-group">
                    <label>Grid Size</label>
                    <select id="grid-size">
                        <option value="20" selected>20√ó20 (Recommended)</option>
                        <option value="24">24√ó24 (More Data)</option>
                        <option value="28">28√ó28 (Advanced)</option>
                    </select>
                </div>
            </div>

            <button class="control-btn" onclick="startTransmission()">üöÄ Start Transmission</button>

            <div class="status" id="transmit-status">Ready to transmit</div>

            <canvas id="display-canvas"></canvas>

            <div class="stats" id="transmit-stats" style="display: none;">
                <div class="stat-item">
                    <div class="stat-label">Total Bytes</div>
                    <div class="stat-value" id="total-bytes">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Frame</div>
                    <div class="stat-value" id="current-frame">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Progress</div>
                    <div class="stat-value" id="progress-percent">0%</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">FPS</div>
                    <div class="stat-value" id="actual-fps">0</div>
                </div>
            </div>
        </div>

        <!-- Receive Section -->
        <div id="receive-section" class="section">
            <div class="info-box">
                <strong>üì± Instructions:</strong><br>
                1. Set the same FPS as transmitter<br>
                2. Click "Start Camera" and allow camera access<br>
                3. Point at the RED BORDERED grid on laptop<br>
                4. Keep screen brightness HIGH and phone steady<br>
                5. Watch the debug view to see detection
            </div>

            <div class="controls">
                <div class="control-group">
                    <label>Scan Frequency (Hz): <span id="scan-fps-value">8</span></label>
                    <input type="range" id="scan-fps-slider" min="4" max="15" value="8" oninput="updateScanFPS(this.value)">
                </div>
                <div class="control-group">
                    <label>Brightness Threshold: <span id="threshold-value">128</span></label>
                    <input type="range" id="threshold-slider" min="50" max="200" value="128" oninput="updateThreshold(this.value)">
                </div>
            </div>

            <button class="control-btn" id="camera-btn" onclick="toggleCamera()">üì∑ Start Camera</button>

            <div class="status" id="receive-status">Camera not started</div>

            <div class="video-container">
                <video id="video" autoplay playsinline></video>
                <canvas class="detection-overlay" id="overlay-canvas"></canvas>
            </div>

            <canvas id="debug-canvas"></canvas>

            <div class="log" id="log"></div>

            <div class="progress-bar">
                <div class="progress-fill" id="receive-progress" style="width: 0%">0%</div>
            </div>

            <div class="stats" id="receive-stats" style="display: none;">
                <div class="stat-item">
                    <div class="stat-label">Received</div>
                    <div class="stat-value" id="received-bytes">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Expected</div>
                    <div class="stat-value" id="expected-bytes">?</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Frames</div>
                    <div class="stat-value" id="frames-decoded">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Detection</div>
                    <div class="stat-value" id="detection-rate">0%</div>
                </div>
            </div>

            <div class="preview-container" id="receive-preview">
                <p style="text-align: center; color: #999;">Received data will appear here...</p>
            </div>
        </div>
    </div>

    <script>
        let currentMode = 'transmit';
        let transmitting = false;
        let receiving = false;
        let fileData = null;
        let fileName = null;
        let fileType = null;
        
        // Transmission
        let fps = 8;
        let gridSize = 20;
        let transmitInterval = null;
        let currentFrameIndex = 0;
        let frames = [];
        
        // Reception
        let scanInterval = null;
        let scanFPS = 8;
        let threshold = 128;
        let receivedFrames = {};
        let totalFrames = 0;
        let dataLength = 0;
        let receivedDataType = null;
        let detectionAttempts = 0;
        let successfulDetections = 0;

        function setMode(mode) {
            currentMode = mode;
            document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.section').forEach(sec => sec.classList.remove('active'));
            
            if (mode === 'transmit') {
                document.querySelectorAll('.mode-btn')[0].classList.add('active');
                document.getElementById('transmit-section').classList.add('active');
            } else {
                document.querySelectorAll('.mode-btn')[1].classList.add('active');
                document.getElementById('receive-section').classList.add('active');
            }
        }

        function updateFPS(value) {
            fps = parseInt(value);
            document.getElementById('fps-value').textContent = fps;
        }

        function updateScanFPS(value) {
            scanFPS = parseInt(value);
            document.getElementById('scan-fps-value').textContent = scanFPS;
        }

        function updateThreshold(value) {
            threshold = parseInt(value);
            document.getElementById('threshold-value').textContent = threshold;
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (file.size > 100000) {
                alert('File too large! Please use files under 100KB');
                return;
            }

            fileName = file.name;
            fileType = file.type;
            document.getElementById('file-name').textContent = `Selected: ${fileName} (${(file.size / 1024).toFixed(1)} KB)`;

            const reader = new FileReader();
            reader.onload = function(e) {
                fileData = new Uint8Array(e.target.result);
            };
            reader.readAsArrayBuffer(file);
        }

        function startTransmission() {
            if (transmitting) {
                stopTransmission();
                return;
            }

            const textInput = document.getElementById('text-input').value;
            let dataToSend;
            let dataType = 'text';

            if (fileData) {
                dataToSend = fileData;
                dataType = fileType || 'application/octet-stream';
            } else if (textInput) {
                dataToSend = new TextEncoder().encode(textInput);
                dataType = 'text/plain';
            } else {
                alert('Please enter text or select a file');
                return;
            }

            gridSize = parseInt(document.getElementById('grid-size').value);
            
            frames = encodeDataToFrames(dataToSend, dataType, gridSize);
            currentFrameIndex = 0;
            
            transmitting = true;
            document.querySelector('#transmit-section .control-btn').textContent = '‚èπÔ∏è Stop Transmission';
            document.getElementById('transmit-status').textContent = 'Transmitting...';
            document.getElementById('transmit-status').className = 'status active';
            document.getElementById('transmit-stats').style.display = 'grid';
            document.getElementById('total-bytes').textContent = dataToSend.length;
            
            const canvas = document.getElementById('display-canvas');
            canvas.width = gridSize;
            canvas.height = gridSize;
            
            let frameCount = 0;
            let lastFPSUpdate = Date.now();
            
            transmitInterval = setInterval(() => {
                if (currentFrameIndex < frames.length) {
                    drawFrame(canvas, frames[currentFrameIndex]);
                    currentFrameIndex++;
                    
                    document.getElementById('current-frame').textContent = `${currentFrameIndex}/${frames.length}`;
                    const progress = (currentFrameIndex / frames.length * 100).toFixed(1);
                    document.getElementById('progress-percent').textContent = progress + '%';
                    
                    frameCount++;
                    const now = Date.now();
                    if (now - lastFPSUpdate >= 1000) {
                        document.getElementById('actual-fps').textContent = frameCount;
                        frameCount = 0;
                        lastFPSUpdate = now;
                    }
                } else {
                    currentFrameIndex = 0;
                }
            }, 1000 / fps);
        }

        function stopTransmission() {
            transmitting = false;
            clearInterval(transmitInterval);
            document.querySelector('#transmit-section .control-btn').textContent = 'üöÄ Start Transmission';
            document.getElementById('transmit-status').textContent = 'Stopped';
            document.getElementById('transmit-status').className = 'status';
        }

        function encodeDataToFrames(data, dataType, gridSize) {
            const frames = [];
            const bytesPerFrame = Math.floor((gridSize * gridSize - 20) / 8) * 8;
            
            const header = {
                len: data.length,
                type: dataType,
                grid: gridSize
            };
            const headerStr = JSON.stringify(header);
            const headerBytes = new TextEncoder().encode(headerStr);
            
            // Header frame
            const headerFrame = new Uint8Array(gridSize * gridSize);
            // Corners for detection (white squares)
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    headerFrame[i * gridSize + j] = 255;
                    headerFrame[i * gridSize + (gridSize - 1 - j)] = 255;
                    headerFrame[(gridSize - 1 - i) * gridSize + j] = 255;
                    headerFrame[(gridSize - 1 - i) * gridSize + (gridSize - 1 - j)] = 255;
                }
            }
            // Header marker (center top)
            headerFrame[2 * gridSize + Math.floor(gridSize / 2)] = 255;
            
            // Pack header data
            for (let i = 0; i < headerBytes.length && i < bytesPerFrame; i++) {
                const byte = headerBytes[i];
                const startIdx = 20 + i * 8;
                for (let bit = 0; bit < 8; bit++) {
                    headerFrame[startIdx + bit] = (byte & (1 << (7 - bit))) ? 255 : 0;
                }
            }
            frames.push(headerFrame);
            
            // Data frames
            for (let offset = 0; offset < data.length; offset += bytesPerFrame) {
                const frame = new Uint8Array(gridSize * gridSize);
                
                // Corners
                for (let i = 0; i < 4; i++) {
                    for (let j = 0; j < 4; j++) {
                        frame[i * gridSize + j] = 255;
                        frame[i * gridSize + (gridSize - 1 - j)] = 255;
                        frame[(gridSize - 1 - i) * gridSize + j] = 255;
                        frame[(gridSize - 1 - i) * gridSize + (gridSize - 1 - j)] = 255;
                    }
                }
                
                // Frame number in center top (3 bytes = 24 bits)
                const frameNum = Math.floor(offset / bytesPerFrame) + 1;
                for (let bit = 0; bit < 24; bit++) {
                    const idx = 2 * gridSize + Math.floor(gridSize / 2) - 12 + bit;
                    frame[idx] = (frameNum & (1 << (23 - bit))) ? 255 : 0;
                }
                
                // Data
                for (let i = 0; i < bytesPerFrame && offset + i < data.length; i++) {
                    const byte = data[offset + i];
                    const startIdx = 20 + i * 8;
                    for (let bit = 0; bit < 8; bit++) {
                        if (startIdx + bit < frame.length) {
                            frame[startIdx + bit] = (byte & (1 << (7 - bit))) ? 255 : 0;
                        }
                    }
                }
                
                frames.push(frame);
            }
            
            return frames;
        }

        function drawFrame(canvas, frameData) {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.createImageData(canvas.width, canvas.height);
            
            for (let i = 0; i < frameData.length; i++) {
                const idx = i * 4;
                const val = frameData[i];
                imageData.data[idx] = val;
                imageData.data[idx + 1] = val;
                imageData.data[idx + 2] = val;
                imageData.data[idx + 3] = 255;
            }
            
            ctx.putImageData(imageData, 0, 0);
        }

        // RECEIVER
        async function toggleCamera() {
            if (receiving) {
                stopCamera();
            } else {
                await startCamera();
            }
        }

        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { 
                        facingMode: 'environment',
                        width: { ideal: 1920 },
                        height: { ideal: 1080 }
                    } 
                });
                
                const video = document.getElementById('video');
                video.srcObject = stream;
                
                await new Promise(resolve => {
                    video.onloadedmetadata = () => {
                        video.play();
                        resolve();
                    };
                });
                
                const overlay = document.getElementById('overlay-canvas');
                overlay.width = video.videoWidth;
                overlay.height = video.videoHeight;
                
                receiving = true;
                document.getElementById('camera-btn').textContent = '‚èπÔ∏è Stop Camera';
                document.getElementById('receive-status').textContent = 'Scanning for grid...';
                document.getElementById('receive-status').className = 'status active';
                document.getElementById('receive-stats').style.display = 'grid';
                
                receivedFrames = {};
                totalFrames = 0;
                dataLength = 0;
                detectionAttempts = 0;
                successfulDetections = 0;
                
                scanInterval = setInterval(scanFrame, 1000 / scanFPS);
                
                log('Camera started, looking for grid...');
            } catch (err) {
                alert('Camera error: ' + err.message);
                log('ERROR: ' + err.message);
            }
        }

        function stopCamera() {
            receiving = false;
            clearInterval(scanInterval);
            
            const video = document.getElementById('video');
            if (video.srcObject) {
                video.srcObject.getTracks().forEach(track => track.stop());
                video.srcObject = null;
            }
            
            document.getElementById('camera-btn').textContent = 'üì∑ Start Camera';
            document.getElementById('receive-status').textContent = 'Stopped';
            document.getElementById('receive-status').className = 'status';
        }

        function scanFrame() {
            const video = document.getElementById('video');
            if (video.readyState !== video.HAVE_ENOUGH_DATA) return;
            
            detectionAttempts++;
            
            // Create processing canvas
            const procCanvas = document.createElement('canvas');
            procCanvas.width = video.videoWidth;
            procCanvas.height = video.videoHeight;
            const procCtx = procCanvas.getContext('2d');
            procCtx.drawImage(video, 0, 0);
            
            // Find red border
            const bounds = findRedBorder(procCtx, procCanvas.width, procCanvas.height);
            
            if (!bounds) {
                if (detectionAttempts % 10 === 0) {
                    log('No red border detected');
                    document.getElementById('receive-status').textContent = 'Looking for RED border...';
                    document.getElementById('receive-status').className = 'status warning';
                }
                return;
            }
            
            // Extract and process grid
            const gridData = extractGrid(procCtx, bounds);
            
            if (gridData) {
                successfulDetections++;
                const rate = ((successfulDetections / detectionAttempts) * 100).toFixed(0);
                document.getElementById('detection-rate').textContent = rate + '%';
                document.getElementById('receive-status').textContent = 'Decoding data...';
                document.getElementById('receive-status').className = 'status active';
                
                const decoded = decodeGrid(gridData);
                if (decoded) {
                    processDecodedFrame(decoded);
                }
                
                // Show debug view
                showDebugView(gridData);
            }
        }

        function findRedBorder(ctx, width, height) {
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            
            // Sample points to find red pixels
            const redPoints = [];
            const step = 10;
            
            for (let y = 0; y < height; y += step) {
                for (let x = 0; x < width; x += step) {
                    const idx = (y * width + x) * 4;
                    const r = data[idx];
                    const g = data[idx + 1];
                    const b = data[idx + 2];
                    
                    // Red detection: high R, low G and B
                    if (r > 150 && g < 100 && b < 100 && r > g + 50 && r > b + 50) {
                        redPoints.push({ x, y });
                    }
                }
            }
            
            if (redPoints.length < 20) return null;
            
            // Find bounding box of red points
            let minX = width, maxX = 0, minY = height, maxY = 0;
            for (const p of redPoints) {
                minX = Math.min(minX, p.x);
                maxX = Math.max(maxX, p.x);
                minY = Math.min(minY, p.y);
                maxY = Math.max(maxY, p.y);
            }
            
            // Add padding and ensure square-ish
            const padding = 20;
            minX = Math.max(0, minX - padding);
            maxX = Math.min(width, maxX + padding);
            minY = Math.max(0, minY - padding);
            maxY = Math.min(height, maxY + padding);
            
            const w = maxX - minX;
            const h = maxY - minY;
            
            if (w < 100 || h < 100 || w > width * 0.9 || h > height * 0.9) return null;
            
            return { x: minX, y: minY, width: w, height: h };
        }

        function extractGrid(ctx, bounds) {
            // Try different grid sizes
            for (const size of [20, 24, 28, 16, 32]) {
                const canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;
                const tempCtx = canvas.getContext('2d');
                
                tempCtx.drawImage(
                    ctx.canvas,
                    bounds.x, bounds.y, bounds.width, bounds.height,
                    0, 0, size, size
                );
                
                const imageData = tempCtx.getImageData(0, 0, size, size);
                const data = imageData.data;
                const grid = new Uint8Array(size * size);
                
                // Convert to grayscale
                for (let i = 0; i < size * size; i++) {
                    const idx = i * 4;
                    grid[i] = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
                }
                
// Check if corners are white (detection markers)
                let cornerSum = 0;
                for (let i = 0; i < 4; i++) {
                    for (let j = 0; j < 4; j++) {
                        cornerSum += grid[i * size + j];
                        cornerSum += grid[i * size + (size - 1 - j)];
                        cornerSum += grid[(size - 1 - i) * size + j];
                        cornerSum += grid[(size - 1 - i) * size + (size - 1 - j)];
                    }
                }
                
                const avgCorner = cornerSum / 64;
                if (avgCorner > 180) {
                    return { grid, size };
                }
            }
            
            return null;
        }

        function decodeGrid(gridData) {
            const { grid, size } = gridData;
            
            // Apply adaptive thresholding
            const binary = new Uint8Array(size * size);
            for (let i = 0; i < grid.length; i++) {
                binary[i] = grid[i] > threshold ? 255 : 0;
            }
            
            // Check if this is a header frame (center top pixel is white)
            const isHeader = binary[2 * size + Math.floor(size / 2)] > 128;
            
            // Decode frame number from center top (24 bits)
            let frameNum = 0;
            if (!isHeader) {
                for (let bit = 0; bit < 24; bit++) {
                    const idx = 2 * size + Math.floor(size / 2) - 12 + bit;
                    if (binary[idx] > 128) {
                        frameNum |= (1 << (23 - bit));
                    }
                }
            }
            
            // Extract data bits
            const bytesPerFrame = Math.floor((size * size - 20) / 8);
            const bytes = [];
            
            for (let i = 0; i < bytesPerFrame; i++) {
                let byte = 0;
                const startIdx = 20 + i * 8;
                
                if (startIdx + 7 < binary.length) {
                    for (let bit = 0; bit < 8; bit++) {
                        if (binary[startIdx + bit] > 128) {
                            byte |= (1 << (7 - bit));
                        }
                    }
                    bytes.push(byte);
                }
            }
            
            return {
                isHeader,
                frameNum,
                bytes: new Uint8Array(bytes),
                size
            };
        }

        function processDecodedFrame(decoded) {
            if (decoded.isHeader) {
                // Try to parse header
                try {
                    const headerStr = new TextDecoder().decode(decoded.bytes);
                    const nullIdx = headerStr.indexOf('\0');
                    const cleanStr = nullIdx >= 0 ? headerStr.substring(0, nullIdx) : headerStr;
                    const header = JSON.parse(cleanStr);
                    
                    dataLength = header.len;
                    receivedDataType = header.type;
                    totalFrames = Math.ceil(dataLength / decoded.bytes.length) + 1;
                    
                    document.getElementById('expected-bytes').textContent = dataLength;
                    log(`Header decoded: ${dataLength} bytes, type: ${receivedDataType}`);
                    
                    receivedFrames[0] = decoded;
                } catch (e) {
                    // Header not complete or corrupted
                }
            } else {
                if (decoded.frameNum > 0 && !receivedFrames[decoded.frameNum]) {
                    receivedFrames[decoded.frameNum] = decoded;
                    document.getElementById('frames-decoded').textContent = Object.keys(receivedFrames).length;
                    log(`Frame ${decoded.frameNum} decoded`);
                }
            }
            
            // Try to reconstruct data
            if (dataLength > 0) {
                reconstructData();
            }
        }

        function reconstructData() {
            // Get all data frames in order
            const frameNums = Object.keys(receivedFrames)
                .map(k => parseInt(k))
                .filter(k => k > 0)
                .sort((a, b) => a - b);
            
            if (frameNums.length === 0) return;
            
            // Concatenate bytes
            const allBytes = [];
            for (const num of frameNums) {
                const frame = receivedFrames[num];
                allBytes.push(...frame.bytes);
            }
            
            const receivedBytes = Math.min(allBytes.length, dataLength);
            document.getElementById('received-bytes').textContent = receivedBytes;
            
            if (dataLength > 0) {
                const progress = Math.min(100, (receivedBytes / dataLength * 100));
                document.getElementById('receive-progress').style.width = progress + '%';
                document.getElementById('receive-progress').textContent = progress.toFixed(0) + '%';
            }
            
            // Display data
            if (receivedBytes > 0) {
                const data = new Uint8Array(allBytes.slice(0, dataLength));
                displayReceivedData(data);
            }
            
            if (receivedBytes >= dataLength && dataLength > 0) {
                document.getElementById('receive-status').textContent = 'Transfer complete!';
                document.getElementById('receive-status').className = 'status';
                log('‚úì Transfer complete!');
            }
        }

        function displayReceivedData(data) {
            const preview = document.getElementById('receive-preview');
            preview.innerHTML = '';
            
            if (receivedDataType && receivedDataType.startsWith('image/')) {
                const blob = new Blob([data], { type: receivedDataType });
                const url = URL.createObjectURL(blob);
                const img = document.createElement('img');
                img.src = url;
                img.style.maxWidth = '100%';
                img.onload = () => log('Image rendered');
                preview.appendChild(img);
            } else {
                try {
                    const text = new TextDecoder().decode(data);
                    const pre = document.createElement('pre');
                    pre.textContent = text;
                    preview.appendChild(pre);
                    log(`Text: "${text.substring(0, 50)}..."`);
                } catch (e) {
                    preview.innerHTML = `<p>Binary data (${data.length} bytes)</p>`;
                }
            }
        }

        function showDebugView(gridData) {
            const debugCanvas = document.getElementById('debug-canvas');
            const { grid, size } = gridData;
            
            debugCanvas.width = size * 10;
            debugCanvas.height = size * 10;
            const ctx = debugCanvas.getContext('2d');
            
            const imageData = ctx.createImageData(size, size);
            for (let i = 0; i < grid.length; i++) {
                const idx = i * 4;
                const val = grid[i] > threshold ? 255 : 0;
                imageData.data[idx] = val;
                imageData.data[idx + 1] = val;
                imageData.data[idx + 2] = val;
                imageData.data[idx + 3] = 255;
            }
            
            // Scale up
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = size;
            tempCanvas.height = size;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.putImageData(imageData, 0, 0);
            
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(tempCanvas, 0, 0, size, size, 0, 0, size * 10, size * 10);
        }

        function log(message) {
            const logEl = document.getElementById('log');
            const time = new Date().toLocaleTimeString();
            logEl.innerHTML += `[${time}] ${message}<br>`;
            logEl.scrollTop = logEl.scrollHeight;
            
            // Keep only last 10 messages
            const lines = logEl.innerHTML.split('<br>');
            if (lines.length > 10) {
                logEl.innerHTML = lines.slice(-10).join('<br>');
            }
        }
    </script>
</body>
</html>
